{"version":3,"sources":["System/Types.js","System/Types.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","VOID0","_BOOLEAN","_NUMBER","_STRING","_OBJECT","_UNDEFINED","_FUNCTION","typeInfoRegistry","TypeInfo","target","_","this","isBoolean","isNumber","isString","isTrueNaN","isObject","isFunction","isUndefined","isNull","isPrimitive","type","isNaN","isFinite","isValidNumber","isNullOrUndefined","Object","freeze","prototype","member","name","t","getFor","info","Type","value","allowNaN","numberOrNaN","NaN","of","hasMember","property","hasMemberOfType","instance","isArrayLike","Array","BOOLEAN","NUMBER","STRING","OBJECT","UNDEFINED","FUNCTION","defineProperty"],"mappings":"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","file":"System/Types.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    'use strict';\n    var VOID0 = void (0), _BOOLEAN = typeof true, _NUMBER = typeof 0, _STRING = typeof \"\", _OBJECT = typeof {}, _UNDEFINED = typeof VOID0, _FUNCTION = typeof function () { };\n    var typeInfoRegistry = {};\n    var TypeInfo = (function () {\n        function TypeInfo(target) {\n            var _ = this;\n            _.isBoolean = false;\n            _.isNumber = false;\n            _.isString = false;\n            _.isTrueNaN = false;\n            _.isObject = false;\n            _.isFunction = false;\n            _.isUndefined = false;\n            _.isNull = false;\n            _.isPrimitive = false;\n            switch (_.type = typeof target) {\n                case _BOOLEAN:\n                    _.isBoolean = true;\n                    _.isPrimitive = true;\n                    break;\n                case _NUMBER:\n                    _.isNumber = true;\n                    _.isTrueNaN = isNaN(target);\n                    _.isFinite = isFinite(target);\n                    _.isValidNumber = !_.isTrueNaN;\n                    _.isPrimitive = true;\n                    break;\n                case _STRING:\n                    _.isString = true;\n                    _.isPrimitive = true;\n                    break;\n                case _OBJECT:\n                    _.target = target;\n                    if (target === null) {\n                        _.isNull = true;\n                        _.isNullOrUndefined = true;\n                        _.isPrimitive = true;\n                    }\n                    else {\n                        _.isObject = true;\n                    }\n                    break;\n                case _FUNCTION:\n                    _.target = target;\n                    _.isString = true;\n                    break;\n                case _UNDEFINED:\n                    _.isUndefined = true;\n                    _.isNullOrUndefined = true;\n                    _.isPrimitive = true;\n                    break;\n                default:\n                    throw \"Fatal type failure.  Unknown type: \" + _.type;\n            }\n            Object.freeze(_);\n        }\n        TypeInfo.prototype.member = function (name) {\n            var t = this.target;\n            return TypeInfo.getFor(t && (name) in (t)\n                ? t[name]\n                : undefined);\n        };\n        TypeInfo.getFor = function (target) {\n            var type = typeof target;\n            switch (type) {\n                case _OBJECT:\n                case _FUNCTION:\n                    return new TypeInfo(target);\n            }\n            var info = typeInfoRegistry[type];\n            if (!info)\n                typeInfoRegistry[type] = info = new TypeInfo(target);\n            return info;\n        };\n        return TypeInfo;\n    }());\n    exports.TypeInfo = TypeInfo;\n    var Type;\n    (function (Type) {\n        Type.BOOLEAN = _BOOLEAN;\n        Type.NUMBER = _NUMBER;\n        Type.STRING = _STRING;\n        Type.OBJECT = _OBJECT;\n        Type.UNDEFINED = _UNDEFINED;\n        Type.FUNCTION = _FUNCTION;\n        function isBoolean(value) {\n            return typeof value === _BOOLEAN;\n        }\n        Type.isBoolean = isBoolean;\n        function isNumber(value, allowNaN) {\n            if (allowNaN === VOID0)\n                allowNaN = true;\n            return typeof value === _NUMBER && (allowNaN || !isNaN(value));\n        }\n        Type.isNumber = isNumber;\n        function isTrueNaN(value) {\n            return typeof value === _NUMBER && isNaN(value);\n        }\n        Type.isTrueNaN = isTrueNaN;\n        function isString(value) {\n            return typeof value === _STRING;\n        }\n        Type.isString = isString;\n        function isPrimitive(value) {\n            var t = typeof value;\n            switch (t) {\n                case _BOOLEAN:\n                case _STRING:\n                case _NUMBER:\n                case _UNDEFINED:\n                    return true;\n                case _OBJECT:\n                    return value === null;\n            }\n            return false;\n        }\n        Type.isPrimitive = isPrimitive;\n        function isFunction(value) {\n            return typeof value === _FUNCTION;\n        }\n        Type.isFunction = isFunction;\n        function isObject(value) {\n            return typeof value === _OBJECT;\n        }\n        Type.isObject = isObject;\n        function numberOrNaN(value) {\n            return isNaN(value) ? NaN : value;\n        }\n        Type.numberOrNaN = numberOrNaN;\n        function of(target) {\n            return TypeInfo.getFor(target);\n        }\n        Type.of = of;\n        function hasMember(value, property) {\n            return value && !isPrimitive(value) && (property) in (value);\n        }\n        Type.hasMember = hasMember;\n        function hasMemberOfType(instance, property, type) {\n            return hasMember(instance, property) && typeof (instance[property]) === type;\n        }\n        Type.hasMemberOfType = hasMemberOfType;\n        function isArrayLike(instance) {\n            return instance instanceof Array || hasMember(instance, \"length\");\n        }\n        Type.isArrayLike = isArrayLike;\n    })(Type || (Type = {}));\n    Object.freeze(Type);\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Type;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"Primitive.d.ts\"/>\r\n///<reference path=\"Collections/Array/IArray.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\n\r\nconst\r\n\tVOID0:any = void(0),\r\n\t_BOOLEAN:string = typeof true,\r\n\t_NUMBER:string  = typeof 0,\r\n\t_STRING:string  = typeof \"\",\r\n\t_OBJECT:string  = typeof {},\r\n\t_UNDEFINED:string = typeof VOID0,\r\n\t_FUNCTION:string = typeof function() {};\r\n\r\n// Only used for primitives.\r\nvar typeInfoRegistry:{[key:string]:TypeInfo} = {};\r\n\r\n/**\r\n * Exposes easy access to type information including inquiring about members.\r\n */\r\nexport class TypeInfo\r\n{\r\n\t// Not retained for primitives. Since they have no members.\r\n\tprivate target:any;\r\n\r\n\ttype:string;\r\n\r\n\tisBoolean:boolean;\r\n\tisNumber:boolean;\r\n\tisFinite:boolean;\r\n\tisValidNumber:boolean;\r\n\tisString:boolean;\r\n\tisTrueNaN:boolean;\r\n\tisObject:boolean;\r\n\tisFunction:boolean;\r\n\tisUndefined:boolean;\r\n\tisNull:boolean;\r\n\tisNullOrUndefined:boolean;\r\n\tisPrimitive:boolean;\r\n\r\n\tconstructor(target:any)\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.isBoolean = false;\r\n\t\t_.isNumber = false;\r\n\t\t_.isString = false;\r\n\t\t_.isTrueNaN = false;\r\n\t\t_.isObject = false;\r\n\t\t_.isFunction = false;\r\n\t\t_.isUndefined = false;\r\n\t\t_.isNull = false;\r\n\t\t_.isPrimitive = false;\r\n\r\n\t\tswitch(_.type = typeof target)\r\n\t\t{\r\n\t\t\tcase _BOOLEAN:\r\n\t\t\t\t_.isBoolean = true;\r\n\t\t\t\t_.isPrimitive = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase _NUMBER:\r\n\t\t\t\t_.isNumber = true;\r\n\t\t\t\t_.isTrueNaN = isNaN(target);\r\n\t\t\t\t_.isFinite = isFinite(target);\r\n\t\t\t\t_.isValidNumber = !_.isTrueNaN;\r\n\t\t\t\t_.isPrimitive = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase _STRING:\r\n\t\t\t\t_.isString = true;\r\n\t\t\t\t_.isPrimitive = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase _OBJECT:\r\n\t\t\t\t_.target = target;\r\n\t\t\t\tif(target===null)\r\n\t\t\t\t{\r\n\t\t\t\t\t_.isNull = true;\r\n\t\t\t\t\t_.isNullOrUndefined = true;\r\n\t\t\t\t\t_.isPrimitive = true;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t_.isObject = true;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase _FUNCTION:\r\n\t\t\t\t_.target = target;\r\n\t\t\t\t_.isString = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase _UNDEFINED:\r\n\t\t\t\t_.isUndefined = true;\r\n\t\t\t\t_.isNullOrUndefined = true;\r\n\t\t\t\t_.isPrimitive = true;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow \"Fatal type failure.  Unknown type: \" + _.type;\r\n\t\t}\r\n\r\n\t\tObject.freeze(_);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a TypeInfo for any member or non-member,\r\n\t * where non-members are of type undefined.\r\n\t * @param name\r\n\t * @returns {TypeInfo}\r\n\t */\r\n\tmember(name:string):TypeInfo\r\n\t{\r\n\t\tvar t = this.target;\r\n\t\treturn TypeInfo.getFor(\r\n\t\t\tt && (name)in(t)\r\n\t\t\t\t? t[name]\r\n\t\t\t\t: undefined);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a TypeInfo for any target object.\r\n\t * If the target object is of a primitive type, it returns the TypeInfo instance assigned to that type.\r\n\t * @param target\r\n\t * @returns {TypeInfo}\r\n\t */\r\n\tstatic getFor(target:any):TypeInfo\r\n\t{\r\n\t\tvar type:string = typeof target;\r\n\t\tswitch(type)\r\n\t\t{\r\n\t\t\tcase _OBJECT:\r\n\t\t\tcase _FUNCTION:\r\n\t\t\t\treturn new TypeInfo(target);\r\n\t\t}\r\n\t\tvar info = typeInfoRegistry[type];\r\n\t\tif(!info) typeInfoRegistry[type] = info = new TypeInfo(target);\r\n\t\treturn info;\r\n\t}\r\n\r\n}\r\n\r\nmodule Type\r\n{\r\n\t/**\r\n\t * typeof true\r\n\t * @type {string}\r\n\t */\r\n\texport const BOOLEAN:string = _BOOLEAN;\r\n\r\n\t/**\r\n\t * typeof 0\r\n\t * @type {string}\r\n\t */\r\n\texport const NUMBER:string = _NUMBER;\r\n\r\n\t/**\r\n\t * typeof \"\"\r\n\t * @type {string}\r\n\t */\r\n\texport const STRING:string = _STRING;\r\n\r\n\t/**\r\n\t * typeof {}\r\n\t * @type {string}\r\n\t */\r\n\texport const OBJECT:string = _OBJECT;\r\n\r\n\r\n\t/**\r\n\t * typeof undefined\r\n\t * @type {string}\r\n\t */\r\n\texport const UNDEFINED:string = _UNDEFINED;\r\n\r\n\t/**\r\n\t * typeof function\r\n\t * @type {string}\r\n\t */\r\n\texport const FUNCTION:string = _FUNCTION;\r\n\r\n\t/**\r\n\t * Returns true if the value parameter is a boolean.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isBoolean(value:any):value is boolean\r\n\t{\r\n\t\treturn typeof value===_BOOLEAN;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value parameter is a number.\r\n\t * @param value\r\n\t * @param allowNaN Default is true.\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isNumber(value:any, allowNaN?:boolean):value is number\r\n\t{\r\n\t\tif(allowNaN===VOID0) allowNaN = true;\r\n\t\treturn typeof value===_NUMBER && (allowNaN || !isNaN(value));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if is a number and is NaN.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isTrueNaN(value:any):value is number\r\n\t{\r\n\t\treturn typeof value===_NUMBER && isNaN(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value parameter is a string.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isString(value:any):value is string\r\n\t{\r\n\t\treturn typeof value===_STRING;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value is a boolean, string, number, null, or undefined.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isPrimitive(value:any):value is Primitive\r\n\t{\r\n\t\tvar t = typeof value;\r\n\t\tswitch(t)\r\n\t\t{\r\n\t\t\tcase _BOOLEAN:\r\n\t\t\tcase _STRING:\r\n\t\t\tcase _NUMBER:\r\n\t\t\tcase _UNDEFINED:\r\n\t\t\t\treturn true;\r\n\t\t\tcase _OBJECT:\r\n\t\t\t\treturn value===null;\r\n\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value parameter is a function.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isFunction(value:any):value is Function\r\n\t{\r\n\t\treturn typeof value===_FUNCTION;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value parameter is an object.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isObject(value:any):boolean\r\n\t{\r\n\t\treturn typeof value===_OBJECT;\r\n\t}\r\n\r\n\t/**\r\n\t * Guarantees a number value or NaN instead.\r\n\t * @param value\r\n\t * @returns {number}\r\n\t */\r\n\texport function numberOrNaN(value:any):number\r\n\t{\r\n\t\treturn isNaN(value) ? NaN : value;\r\n\t}\r\n\r\n\texport function of(target:any):TypeInfo\r\n\t{\r\n\t\treturn TypeInfo.getFor(target);\r\n\t}\r\n\r\n\texport function hasMember(value:any, property:string):boolean\r\n\t{\r\n\t\treturn value && !isPrimitive(value) && (property)in(value);\r\n\t}\r\n\r\n\texport function hasMemberOfType<T>(instance:any, property:string, type:string):instance is T\r\n\t{\r\n\t\treturn hasMember(instance, property) && typeof(instance[property])===type;\r\n\t}\r\n\r\n\texport function isArrayLike<T>(instance:any):instance is IArray<T>\r\n\t{\r\n\t\treturn instance instanceof Array || hasMember(instance, \"length\");\r\n\t}\r\n}\r\n\r\nObject.freeze(Type);\r\n\r\nexport default Type;\r\n"]}