{"version":3,"sources":["System/Text/Utility.js","System/Text/Utility.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","escapeRegExp","source","replace","trim","chars","ignoreCase","EMPTY","escaped","Array","isArray","join","RegExp","format","args","_i","arguments","length","supplant","params","oIsArray","a","b","n","i","parseInt","isNaN","r","Types_1","STRING","NUMBER","BOOLEAN"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QAAoBG,UAANF,IAAiBF,OAAOC,QAAUC,OAElD,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,YAAaN,IAEhD,SAAUI,EAASF,GAClB,YCHJ,SAAAM,GAA6BC,GAC5B,MAAOA,GAAOC,QAAQ,sCAAuC,QAW9D,QAAAC,GAAqBF,EAAeG,EAAuBC,GAE1D,GAAGD,EAAO,CACT,GAAGA,IAAQV,EAAAY,MAAO,MAAOL,EACzB,IAAIM,GAAUP,EAAaQ,MAAMC,QAAQL,GAASA,EAAMM,OAAiBN,EACzE,OAAOH,GAAOC,QAAQ,GAAIS,QAAO,KAAKJ,EAAQ,OAAOA,EAAQ,MAAM,KAAKF,EAAW,IAAI,KAAKX,EAAAY,OAG7F,MAAOL,GAAOC,QAAQ,aAAcR,EAAAY,OASrC,QAAAM,GAAuBX,GDPf,ICO8B,GAAAY,MAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,EAAA,GAAAC,UAAAD,EAErC,OAAOG,GAAShB,EAAQY,GAczB,QAAAI,GAAyBhB,EAAeiB,GAEvC,GAAIC,GAAWX,MAAMC,QAAQS,EAC7B,OAAOjB,GAAOC,QAAQ,gBACrB,SAACkB,EAAUC,GAEV,GAAIC,GAAQD,CACZ,IAAGF,EACH,CACC,GAAII,GAAIC,SAASH,EACbI,OAAMF,KAAID,EAAIC,GAGnB,GAAIG,GAAUR,EAAQI,EACtB,cAAcI,IAEb,IAAKC,GAAAA,WAAKC,OACV,IAAKD,GAAAA,WAAKE,OACV,IAAKF,GAAAA,WAAKG,QACT,MAAOJ,EACR,SACC,MAAON,MAtEZ,GAAAO,GAAA/B,EAAiB,WAEJF,GAAAY,MAAe,GAEZZ,EAAAM,aAAYA,EAYZN,EAAAS,KAAIA,EAiBJT,EAAAkB,OAAMA,EAgBNlB,EAAAuB,SAAQA","file":"System/Text/Utility.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", '../Types'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Types_1 = require('../Types');\n    exports.EMPTY = '';\n    function escapeRegExp(source) {\n        return source.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n    }\n    exports.escapeRegExp = escapeRegExp;\n    function trim(source, chars, ignoreCase) {\n        if (chars) {\n            if (chars === exports.EMPTY)\n                return source;\n            var escaped = escapeRegExp(Array.isArray(chars) ? chars.join() : chars);\n            return source.replace(new RegExp('^[' + escaped + ']+|[' + escaped + ']+$', 'g' + (ignoreCase ? 'i' : '')), exports.EMPTY);\n        }\n        return source.replace(/^\\s+|\\s+$/g, exports.EMPTY);\n    }\n    exports.trim = trim;\n    function format(source) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        return supplant(source, args);\n    }\n    exports.format = format;\n    function supplant(source, params) {\n        var oIsArray = Array.isArray(params);\n        return source.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n            var n = b;\n            if (oIsArray) {\n                var i = parseInt(b);\n                if (!isNaN(i))\n                    n = i;\n            }\n            var r = params[n];\n            switch (typeof r) {\n                case Types_1.default.STRING:\n                case Types_1.default.NUMBER:\n                case Types_1.default.BOOLEAN:\n                    return r;\n                default:\n                    return a;\n            }\n        });\n    }\n    exports.supplant = supplant;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport Type from '../Types';\r\n\r\nexport const EMPTY:string = '';\r\n\r\nexport function escapeRegExp(source:string):string {\r\n\treturn source.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n}\r\n\r\n/**\r\n * Can trim any character or set of characters from the ends of a string.\r\n * Uses a Regex escapement to replace them with empty.\r\n * @param source\r\n * @param chars A string or array of characters desired to be trimmed.\r\n * @param ignoreCase\r\n * @returns {string}\r\n */\r\nexport function trim(source:string, chars?:string|string[],ignoreCase?:boolean):string\r\n{\r\n\tif(chars) {\r\n\t\tif(chars===EMPTY) return source;\r\n\t\tvar escaped = escapeRegExp(Array.isArray(chars) ? chars.join() : <string>chars);\r\n\t\treturn source.replace(new RegExp('^['+escaped+']+|['+escaped+']+$','g'+(ignoreCase?'i':'')),EMPTY);\r\n\t}\r\n\r\n\treturn source.replace(/^\\s+|\\s+$/g, EMPTY);\r\n}\r\n\r\n/**\r\n * Takes any arg\r\n * @param source\r\n * @param args\r\n * @returns {string}\r\n */\r\nexport function format(source:string, ...args:any[])\r\n{\r\n\treturn supplant(source, args);\r\n}\r\n\r\n//\r\n\r\n/**\r\n * This takes a string and replaces '{string}' with the respected parameter.\r\n * Also allows for passing an array in order to use '{n}' notation.\r\n * Not limited to an array's indexes.  For example, {length} is allowed.\r\n * Based upon Crockford's supplant function.\r\n * @param source\r\n * @param params\r\n * @returns {string}\r\n */\r\nexport function supplant(source:string, params:{[key:string]:any}|any[]):string\r\n{\r\n\tvar oIsArray = Array.isArray(params);\r\n\treturn source.replace(/\\{([^{}]*)\\}/g,\r\n\t\t(a:string, b:string):any=>\r\n\t\t{\r\n\t\t\tvar n:any = b;\r\n\t\t\tif(oIsArray)\r\n\t\t\t{\r\n\t\t\t\tlet i = parseInt(b);\r\n\t\t\t\tif(!isNaN(i)) n = i;\r\n\t\t\t}\r\n\r\n\t\t\tvar r = (<any>params)[n];\r\n\t\t\tswitch(typeof r)\r\n\t\t\t{\r\n\t\t\t\tcase Type.STRING:\r\n\t\t\t\tcase Type.NUMBER:\r\n\t\t\t\tcase Type.BOOLEAN:\r\n\t\t\t\t\treturn r;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn a;\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n}\r\n"]}