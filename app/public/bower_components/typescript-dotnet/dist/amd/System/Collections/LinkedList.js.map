{"version":3,"sources":["System/Collections/LinkedList.js","System/Collections/LinkedList.ts"],"names":["define","require","exports","Values","ArrayUtility","Enumerator","EnumeratorBase_1","LinkedNodeList_1","InvalidOperationException_1","ArgumentNullException_1","ensureExternal","node","list","external","LinkedListNode","getInternal","n","_node","InternalNode","value","previous","next","this","prototype","assertDetached","LinkedList","source","_","c","e","from","_listInternal","moveNext","addNode","current","_count","forEach","action","useCopy","array","toArray","length","i","getEnumerator","first","yielder","yieldReturn","yieldBreak","_findFirst","entry","equals","areEqual","_findLast","prev","last","Object","defineProperty","get","enumerable","configurable","add","clear","contains","found","copyTo","index","minLength","initialize","removeOnce","remove","max","Infinity","removedCount","removeNode","getValueAt","getNodeAt","find","findLast","addFirst","addNodeBefore","addLast","removeFirst","removeLast","removed","addBefore","before","addAfter","after","addNodeAfter","_list","_nodeInternal","set","v"],"mappings":"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","file":"System/Collections/LinkedList.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\ndefine([\"require\", \"exports\", \"../Compare\", \"../Collections/Array/Utility\", \"./Enumeration/Enumerator\", \"./Enumeration/EnumeratorBase\", \"./LinkedNodeList\", \"../Exceptions/InvalidOperationException\", \"../Exceptions/ArgumentNullException\"], function (require, exports, Values, ArrayUtility, Enumerator, EnumeratorBase_1, LinkedNodeList_1, InvalidOperationException_1, ArgumentNullException_1) {\n    'use strict';\n    var InternalNode = (function () {\n        function InternalNode(value, previous, next) {\n            this.value = value;\n            this.previous = previous;\n            this.next = next;\n        }\n        InternalNode.prototype.assertDetached = function () {\n            if (this.next || this.previous)\n                throw new InvalidOperationException_1.default(\"Adding a node that is already placed.\");\n        };\n        return InternalNode;\n    }());\n    function ensureExternal(node, list) {\n        if (!node)\n            return null;\n        var external = node.external;\n        if (!external)\n            node.external = external = new LinkedListNode(list, node);\n        return external;\n    }\n    function getInternal(node, list) {\n        if (!node)\n            throw new ArgumentNullException_1.default(\"Cannot be null.\");\n        if (node.list != list)\n            throw new InvalidOperationException_1.default(\"Provided node does not belong to this list.\");\n        var n = node._node;\n        if (!n)\n            throw new InvalidOperationException_1.default(\"Provided node is not valid.\");\n        return n;\n    }\n    var LinkedList = (function () {\n        function LinkedList(source) {\n            var _ = this, c = 0;\n            var e = Enumerator.from(source);\n            var list = _._listInternal = new LinkedNodeList_1.default();\n            while (e.moveNext()) {\n                list.addNode(new InternalNode(e.current));\n                ++c;\n            }\n            _._count = c;\n        }\n        LinkedList.prototype.forEach = function (action, useCopy) {\n            if (useCopy === void 0) { useCopy = false; }\n            if (useCopy) {\n                var array = this.toArray();\n                ArrayUtility.forEach(array, action);\n                array.length = 0;\n            }\n            else {\n                this._listInternal.forEach(function (node, i) { return action(node.value, i); });\n            }\n        };\n        LinkedList.prototype.getEnumerator = function () {\n            var _ = this, current, next;\n            return new EnumeratorBase_1.default(function () {\n                current = null;\n                next = _._listInternal.first;\n            }, function (yielder) {\n                if (next) {\n                    current = next;\n                    next = current && current.next;\n                    return yielder.yieldReturn(current.value);\n                }\n                return yielder.yieldBreak();\n            });\n        };\n        LinkedList.prototype._findFirst = function (entry) {\n            var equals = Values.areEqual, next = this._listInternal.first;\n            while (next) {\n                if (equals(entry, next.value))\n                    return next;\n                next = next.next;\n            }\n            return null;\n        };\n        LinkedList.prototype._findLast = function (entry) {\n            var equals = Values.areEqual, prev = this._listInternal.last;\n            while (prev) {\n                if (equals(entry, prev.value))\n                    return prev;\n                prev = prev.previous;\n            }\n            return null;\n        };\n        Object.defineProperty(LinkedList.prototype, \"count\", {\n            get: function () {\n                return this._count;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedList.prototype, \"isReadOnly\", {\n            get: function () {\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LinkedList.prototype.add = function (entry) {\n            this._listInternal.addNode(new InternalNode(entry));\n            this._count++;\n        };\n        LinkedList.prototype.clear = function () {\n            this._count = 0;\n            return this._listInternal.clear();\n        };\n        LinkedList.prototype.contains = function (entry) {\n            var found = false, equals = Values.areEqual;\n            this.forEach(function (e) { return !(found = equals(entry, e)); });\n            return found;\n        };\n        LinkedList.prototype.copyTo = function (array, index) {\n            if (index === void 0) { index = 0; }\n            if (!array)\n                throw new ArgumentNullException_1.default('array');\n            if (this._listInternal.first) {\n                var minLength = index + this._count;\n                if (array.length < minLength)\n                    array.length = minLength;\n                this.forEach(function (entry, i) {\n                    array[index + i] = entry;\n                });\n            }\n            return array;\n        };\n        LinkedList.prototype.toArray = function () {\n            var array = ArrayUtility.initialize(this._count);\n            return this.copyTo(array);\n        };\n        LinkedList.prototype.removeOnce = function (entry) {\n            return this.remove(entry, 1) !== 0;\n        };\n        LinkedList.prototype.remove = function (entry, max) {\n            if (max === void 0) { max = Infinity; }\n            var equals = Values.areEqual;\n            var _ = this, list = _._listInternal, removedCount = 0;\n            list.forEach(function (node) {\n                if (equals(entry, node.value) && list.removeNode(node)) {\n                    --_._count;\n                    ++removedCount;\n                }\n                return removedCount < max;\n            });\n            return removedCount;\n        };\n        Object.defineProperty(LinkedList.prototype, \"first\", {\n            get: function () {\n                return ensureExternal(this._listInternal.first, this);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedList.prototype, \"last\", {\n            get: function () {\n                return ensureExternal(this._listInternal.last, this);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LinkedList.prototype.getValueAt = function (index) {\n            return this._listInternal.getNodeAt(index).value;\n        };\n        LinkedList.prototype.getNodeAt = function (index) {\n            return ensureExternal(this._listInternal.getNodeAt(index), this);\n        };\n        LinkedList.prototype.find = function (entry) {\n            return ensureExternal(this._findFirst(entry), this);\n        };\n        LinkedList.prototype.findLast = function (entry) {\n            return ensureExternal(this._findLast(entry), this);\n        };\n        LinkedList.prototype.addFirst = function (entry) {\n            this._listInternal.addNodeBefore(new InternalNode(entry));\n            ++this._count;\n        };\n        LinkedList.prototype.addLast = function (entry) {\n            this.add(entry);\n        };\n        LinkedList.prototype.removeFirst = function () {\n            var _ = this, first = _._listInternal.first;\n            if (first && _._listInternal.removeNode(first)) {\n                _._count--;\n            }\n        };\n        LinkedList.prototype.removeLast = function () {\n            var _ = this, last = _._listInternal.last;\n            if (last && _._listInternal.removeNode(last)) {\n                --_._count;\n            }\n        };\n        LinkedList.prototype.removeNode = function (node) {\n            var _ = this, removed = _._listInternal.removeNode(getInternal(node, _));\n            if (removed)\n                --_._count;\n            return removed;\n        };\n        LinkedList.prototype.addBefore = function (before, entry) {\n            this._listInternal.addNodeBefore(new InternalNode(entry), getInternal(before, this));\n            ++this._count;\n        };\n        LinkedList.prototype.addAfter = function (after, entry) {\n            this._listInternal.addNodeAfter(new InternalNode(entry), getInternal(after, this));\n            ++this._count;\n        };\n        LinkedList.prototype.addNodeBefore = function (node, before) {\n            this._listInternal.addNodeBefore(getInternal(before, this), getInternal(node, this));\n            ++this._count;\n        };\n        LinkedList.prototype.addNodeAfter = function (node, after) {\n            this._listInternal.addNodeAfter(getInternal(after, this), getInternal(node, this));\n            ++this._count;\n        };\n        return LinkedList;\n    }());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = LinkedList;\n    var LinkedListNode = (function () {\n        function LinkedListNode(_list, _nodeInternal) {\n            this._list = _list;\n            this._nodeInternal = _nodeInternal;\n        }\n        Object.defineProperty(LinkedListNode.prototype, \"list\", {\n            get: function () {\n                return this._list;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedListNode.prototype, \"previous\", {\n            get: function () {\n                return ensureExternal(this._nodeInternal.previous, this._list);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedListNode.prototype, \"next\", {\n            get: function () {\n                return ensureExternal(this._nodeInternal.next, this._list);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedListNode.prototype, \"value\", {\n            get: function () {\n                return this._nodeInternal.value;\n            },\n            set: function (v) {\n                this._nodeInternal.value = v;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LinkedListNode.prototype.addBefore = function (entry) {\n            this._list.addBefore(this, entry);\n        };\n        LinkedListNode.prototype.addAfter = function (entry) {\n            this._list.addAfter(this, entry);\n        };\n        LinkedListNode.prototype.addNodeBefore = function (before) {\n            this._list.addNodeBefore(this, before);\n        };\n        LinkedListNode.prototype.addNodeAfter = function (after) {\n            this._list.addNodeAfter(this, after);\n        };\n        LinkedListNode.prototype.remove = function () {\n            this._list.removeNode(this);\n        };\n        return LinkedListNode;\n    }());\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"ILinkedListNode.d.ts\"/>\r\n///<reference path=\"ILinkedList.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport * as Values from \"../Compare\";\r\nimport * as ArrayUtility from \"../Collections/Array/Utility\";\r\nimport * as Enumerator from \"./Enumeration/Enumerator\";\r\nimport EnumeratorBase from \"./Enumeration/EnumeratorBase\";\r\nimport LinkedNodeList from \"./LinkedNodeList\";\r\nimport InvalidOperationException from \"../Exceptions/InvalidOperationException\";\r\nimport ArgumentNullException from \"../Exceptions/ArgumentNullException\";\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n/*\r\n * An internal node is used to manage the order without exposing underlying link chain to the consumer.\r\n */\r\nclass InternalNode<T>\r\nimplements ILinkedNode<InternalNode<T>>, INodeWithValue<T>\r\n{\r\n\tconstructor(\r\n\t\tpublic value?:T,\r\n\t\tpublic previous?:InternalNode<T>,\r\n\t\tpublic next?:InternalNode<T>)\r\n\t{\r\n\t}\r\n\r\n\texternal:ILinkedListNode<T>;\r\n\r\n\tassertDetached():void\r\n\t{\r\n\t\tif(this.next || this.previous)\r\n\t\t\tthrow new InvalidOperationException(\r\n\t\t\t\t\"Adding a node that is already placed.\");\r\n\t}\r\n\r\n}\r\n\r\nfunction ensureExternal<T>(node:InternalNode<T>, list:LinkedList<T>):ILinkedListNode<T>\r\n{\r\n\tif(!node)\r\n\t\treturn null;\r\n\r\n\tvar external:ILinkedListNode<T> = node.external;\r\n\tif(!external)\r\n\t\tnode.external = external = new LinkedListNode<T>(list, node);\r\n\r\n\treturn external;\r\n}\r\n\r\nfunction getInternal<T>(node:ILinkedListNode<T>, list:LinkedList<T>):InternalNode<T>\r\n{\r\n\tif(!node)\r\n\t\tthrow new ArgumentNullException(\r\n\t\t\t\"Cannot be null.\");\r\n\r\n\tif(node.list!=list)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node does not belong to this list.\");\r\n\r\n\tvar n:InternalNode<T> = (<any>node)._node;\r\n\tif(!n)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node is not valid.\");\r\n\r\n\treturn n;\r\n}\r\n\r\nexport default\r\nclass LinkedList<T>\r\nimplements ILinkedList<T>\r\n{\r\n\tprivate _listInternal:LinkedNodeList<InternalNode<T>>;\r\n\tprivate _count:number;\r\n\r\n\tconstructor(source?:IEnumerable<T>);\r\n\tconstructor(source?:IArray<T>);\r\n\tconstructor(source:any)\r\n\t{\r\n\t\tvar _ = this, c = 0;\r\n\t\tvar e = Enumerator.from<T>(source);\r\n\r\n\t\tvar list = _._listInternal = new LinkedNodeList<InternalNode<T>>();\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tlist.addNode( new InternalNode<T>(e.current) );\r\n\t\t\t++c;\r\n\t\t}\r\n\r\n\t\t_._count = c;\r\n\t}\r\n\r\n\r\n\t// #region IEnumerateEach<T>\r\n\tforEach(\r\n\t\taction:Predicate<T> | Action<T>,\r\n\t\tuseCopy:boolean = false):void\r\n\t{\r\n\t\tif(useCopy)\r\n\t\t{\r\n\t\t\tvar array = this.toArray();\r\n\t\t\tArrayUtility.forEach(array, action);\r\n\t\t\tarray.length = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis._listInternal.forEach((node, i)=>action(node.value, i));\r\n\t\t}\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region IEnumerable<T>\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\tvar _ = this,\r\n\t\t    current:InternalNode<T>,\r\n\t\t    next:InternalNode<T>;\r\n\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t// Initialize anchor...\r\n\t\t\t\tcurrent = null;\r\n\t\t\t\tnext = _._listInternal.first;\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\r\n\t\t\t\tif(next)\r\n\t\t\t\t{\r\n\t\t\t\t\tcurrent = next;\r\n\t\t\t\t\tnext = current && current.next;\r\n\t\t\t\t\treturn yielder.yieldReturn(current.value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tprivate _findFirst(entry:T):InternalNode<T>\r\n\t{\r\n\t\tvar equals = Values.areEqual,\r\n\t\t    next   = this._listInternal.first;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\tif(equals(entry, next.value))\r\n\t\t\t\treturn next;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate _findLast(entry:T):InternalNode<T>\r\n\t{\r\n\t\tvar equals = Values.areEqual,\r\n\t\t    prev   = this._listInternal.last;\r\n\t\twhile(prev)\r\n\t\t{\r\n\t\t\tif(equals(entry, prev.value))\r\n\t\t\t\treturn prev;\r\n\t\t\tprev = prev.previous;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// #region ICollection<T>\r\n\tget count():number\r\n\t{\r\n\t\treturn this._count;\r\n\t}\r\n\r\n\t//noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols\r\n\tget isReadOnly():boolean\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tadd(entry:T):void\r\n\t{\r\n\t\tthis._listInternal.addNode(new InternalNode(entry));\r\n\t\tthis._count++;\r\n\t}\r\n\r\n\r\n\tclear():number\r\n\t{\r\n\t\tthis._count = 0;\r\n\t\treturn this._listInternal.clear();\r\n\t}\r\n\r\n\r\n\tcontains(entry:T):boolean\r\n\t{\r\n\t\tvar found:boolean = false, equals = Values.areEqual;\r\n\t\tthis.forEach(e => !(found = equals(entry, e)));\r\n\t\treturn found;\r\n\t}\r\n\r\n\tcopyTo(array:T[], index:number = 0):T[]\r\n\t{\r\n\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\tif(this._listInternal.first)\r\n\t\t{\r\n\t\t\tvar minLength = index + this._count;\r\n\t\t\tif(array.length<minLength) array.length = minLength; // Preset the length if need be.\r\n\t\t\tthis.forEach(\r\n\t\t\t\t(entry, i) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tarray[index + i] = entry;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tvar array = ArrayUtility.initialize<T>(this._count);\r\n\t\treturn this.copyTo(array);\r\n\t}\r\n\r\n\tremoveOnce(entry:T):boolean\r\n\t{\r\n\t\treturn this.remove(entry, 1)!==0;\r\n\t}\r\n\r\n\tremove(entry:T, max:number = Infinity):number\r\n\t{\r\n\t\tvar equals = Values.areEqual;\r\n\t\tvar _ = this, list = _._listInternal, removedCount:number = 0;\r\n\r\n\t\tlist.forEach(node=>\r\n\t\t{\r\n\t\t\tif(equals(entry, node.value) && list.removeNode(node))\r\n\t\t\t{\r\n\t\t\t\t--_._count;\r\n\t\t\t\t++removedCount;\r\n\t\t\t}\r\n\t\t\treturn removedCount<max;\r\n\t\t});\r\n\r\n\t\treturn removedCount;\r\n\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\tget first():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._listInternal.first, this);\r\n\t}\r\n\r\n\tget last():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._listInternal.last, this);\r\n\t}\r\n\r\n\t// get methods are available for convenience but is an n*index operation.\r\n\r\n\r\n\tgetValueAt(index:number):T\r\n\t{\r\n\t\treturn this._listInternal.getNodeAt(index).value;\r\n\t}\r\n\r\n\tgetNodeAt(index:number):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._listInternal.getNodeAt(index), this);\r\n\t}\r\n\r\n\tfind(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findFirst(entry), this);\r\n\t}\r\n\r\n\tfindLast(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findLast(entry), this);\r\n\t}\r\n\r\n\taddFirst(entry:T):void\r\n\t{\r\n\t\tthis._listInternal.addNodeBefore(new InternalNode(entry));\r\n\t\t++this._count;\r\n\t}\r\n\r\n\taddLast(entry:T):void\r\n\t{\r\n\t\tthis.add(entry);\r\n\t}\r\n\r\n\tremoveFirst():void\r\n\t{\r\n\t\tvar _ = this, first = _._listInternal.first;\r\n\t\tif(first && _._listInternal.removeNode(first)) {\r\n\t\t\t_._count--;\r\n\t\t}\r\n\t}\r\n\r\n\tremoveLast():void\r\n\t{\r\n\t\tvar _ = this, last = _._listInternal.last;\r\n\t\tif(last && _._listInternal.removeNode(last)) {\r\n\t\t\t--_._count;\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns true if successful and false if not found (already removed).\r\n\tremoveNode(node:ILinkedListNode<T>):boolean\r\n\t{\r\n\t\tvar _ = this,\r\n\t\t    removed = _._listInternal.removeNode(getInternal(node, _));\r\n\r\n\t\tif(removed) --_._count;\r\n\r\n\t\treturn removed;\r\n\t}\r\n\r\n\taddBefore(before:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tthis._listInternal.addNodeBefore(\r\n\t\t\tnew InternalNode(entry),\r\n\t\t\tgetInternal(before, this)\r\n\t\t);\r\n\t\t++this._count;\r\n\t}\r\n\r\n\r\n\taddAfter(after:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tthis._listInternal.addNodeAfter(\r\n\t\t\tnew InternalNode(entry),\r\n\t\t\tgetInternal(after, this)\r\n\t\t);\r\n\t\t++this._count;\r\n\t}\r\n\r\n\taddNodeBefore(node:ILinkedListNode<T>, before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._listInternal.addNodeBefore(\r\n\t\t\tgetInternal(before, this),\r\n\t\t\tgetInternal(node, this)\r\n\t\t);\r\n\t\t++this._count;\r\n\t}\r\n\r\n\taddNodeAfter(node:ILinkedListNode<T>, after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._listInternal.addNodeAfter(\r\n\t\t\tgetInternal(after, this),\r\n\t\t\tgetInternal(node, this)\r\n\t\t);\r\n\t\t++this._count;\r\n\t}\r\n\r\n\r\n}\r\n\r\n// Use an internal node class to prevent mucking up the LinkedList.\r\nclass LinkedListNode<T> implements ILinkedListNode<T>\r\n{\r\n\tconstructor(\r\n\t\tprivate _list:LinkedList<T>,\r\n\t\tprivate _nodeInternal:InternalNode<T>)\r\n\t{\r\n\t}\r\n\r\n\tget list():LinkedList<T>\r\n\t{\r\n\t\treturn this._list;\r\n\t}\r\n\r\n\tget previous():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._nodeInternal.previous, this._list);\r\n\t}\r\n\r\n\tget next():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._nodeInternal.next, this._list);\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this._nodeInternal.value;\r\n\t}\r\n\r\n\tset value(v:T)\r\n\t{\r\n\t\tthis._nodeInternal.value = v;\r\n\t}\r\n\r\n\taddBefore(entry:T):void\r\n\t{\r\n\t\tthis._list.addBefore(this, entry);\r\n\t}\r\n\r\n\taddAfter(entry:T):void\r\n\t{\r\n\t\tthis._list.addAfter(this, entry);\r\n\t}\r\n\r\n\taddNodeBefore(before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeBefore(this, before);\r\n\t}\r\n\r\n\taddNodeAfter(after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeAfter(this, after);\r\n\t}\r\n\r\n\tremove():void\r\n\t{\r\n\t\tthis._list.removeNode(this);\r\n\t}\r\n\r\n}\r\n\r\n"]}