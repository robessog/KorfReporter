{"version":3,"sources":["System/Collections/Queue.js","System/Collections/Queue.ts"],"names":["define","require","exports","Values","AU","Types_1","Integer_1","EnumeratorBase_1","forEach_1","NotImplementedException_1","InvalidOperationException_1","ArgumentOutOfRangeException_1","assertZeroOrGreater","value","property","assertIntegerZeroOrGreater","assert","MINIMUM_GROW","SHRINK_THRESHOLD","GROW_FACTOR_HALF","DEFAULT_CAPACITY","emptyArray","Queue","source","_","this","_head","_tail","_size","_version","isNumber","capacity","_array","initialize","se","isArrayLike","length","e","enqueue","_capacity","Object","defineProperty","prototype","get","enumerable","configurable","add","item","clear","array","head","tail","size","trimExcess","dump","max","Infinity","result","isFinite","push","dequeue","contains","index","count","len","areEqual","copyTo","target","arrayIndex","Error","numToCopy","lh","firstPart","toArray","arr","remove","dispose","forEach","action","copy","i","setCapacity","newArray","newCapacity","throwIfEmpty","removed","tryDequeue","out","d","_getElement","peek","threshold","Math","floor","isNaN","getEnumerator","version","yielder","yieldBreak","yieldReturn"],"mappings":"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","file":"System/Collections/Queue.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Based Upon: http://referencesource.microsoft.com/#System/CompMod/system/collections/generic/queue.cs\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\ndefine([\"require\", \"exports\", '../Compare', './Array/Utility', '../Types', '../Integer', './Enumeration/EnumeratorBase', './Enumeration/forEach', '../Exceptions/NotImplementedException', '../Exceptions/InvalidOperationException', '../Exceptions/ArgumentOutOfRangeException'], function (require, exports, Values, AU, Types_1, Integer_1, EnumeratorBase_1, forEach_1, NotImplementedException_1, InvalidOperationException_1, ArgumentOutOfRangeException_1) {\n    'use strict';\n    var MINIMUM_GROW = 4;\n    var SHRINK_THRESHOLD = 32;\n    var GROW_FACTOR_HALF = 100;\n    var DEFAULT_CAPACITY = MINIMUM_GROW;\n    var emptyArray = [];\n    var Queue = (function () {\n        function Queue(source) {\n            var _ = this;\n            _._head = 0;\n            _._tail = 0;\n            _._size = 0;\n            _._version = 0;\n            if (!source)\n                _._array = emptyArray;\n            else {\n                if (Types_1.default.isNumber(source)) {\n                    var capacity = source;\n                    assertIntegerZeroOrGreater(capacity, \"capacity\");\n                    _._array = capacity\n                        ? AU.initialize(capacity)\n                        : emptyArray;\n                }\n                else {\n                    var se = source;\n                    _._array = AU.initialize(Types_1.default.isArrayLike(se)\n                        ? se.length\n                        : DEFAULT_CAPACITY);\n                    forEach_1.default(se, function (e) { return _.enqueue(e); });\n                    _._version = 0;\n                }\n            }\n            _._capacity = _._array.length;\n        }\n        Object.defineProperty(Queue.prototype, \"count\", {\n            get: function () {\n                return this._size;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Queue.prototype, \"isReadOnly\", {\n            get: function () {\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Queue.prototype.add = function (item) {\n            this.enqueue(item);\n        };\n        Queue.prototype.clear = function () {\n            var _ = this, array = _._array, head = _._head, tail = _._tail, size = _._size;\n            if (head < tail)\n                AU.clear(array, head, size);\n            else {\n                AU.clear(array, head, array.length - head);\n                AU.clear(array, 0, tail);\n            }\n            _._head = 0;\n            _._tail = 0;\n            _._size = 0;\n            _._version++;\n            _.trimExcess();\n            return size;\n        };\n        Queue.prototype.dump = function (max) {\n            if (max === void 0) { max = Infinity; }\n            if (Types_1.default.isNumber(max, false) && max < 0)\n                throw new ArgumentOutOfRangeException_1.default('max', max, 'must be greater than or equal to 0.');\n            var _ = this, result = [];\n            if (isFinite(max)) {\n                Integer_1.default.assert(max, 'max');\n                while (max-- && _._size) {\n                    result.push(_.dequeue());\n                }\n            }\n            else {\n                while (_._size) {\n                    result.push(_.dequeue());\n                }\n            }\n            _.trimExcess();\n            return result;\n        };\n        Queue.prototype.contains = function (item) {\n            var _ = this;\n            var array = _._array, index = _._head, count = _._size, len = _._capacity;\n            while (count-- > 0) {\n                if (Values.areEqual(array[index], item))\n                    return true;\n                index = (index + 1) % len;\n            }\n            return false;\n        };\n        Queue.prototype.copyTo = function (target, arrayIndex) {\n            if (arrayIndex === void 0) { arrayIndex = 0; }\n            if (target == null)\n                throw new Error(\"ArgumentNullException: array cannot be null.\");\n            assertIntegerZeroOrGreater(arrayIndex, \"arrayIndex\");\n            var _ = this, size = _._size;\n            if (!size)\n                return;\n            var numToCopy = size, source = _._array, len = _._capacity, head = _._head, lh = len - head, firstPart = (lh < size)\n                ? lh\n                : size;\n            AU.copyTo(source, target, head, arrayIndex, firstPart);\n            numToCopy -= firstPart;\n            if (numToCopy > 0)\n                AU.copyTo(source, target, 0, arrayIndex + len - head, numToCopy);\n            return target;\n        };\n        Queue.prototype.toArray = function () {\n            var _ = this, size = _._size;\n            var arr = AU.initialize(size);\n            return size ? _.copyTo(arr) : arr;\n        };\n        Queue.prototype.remove = function (item) {\n            throw new NotImplementedException_1.default(\"ICollection\\<T\\>.remove is not implemented in Queue\\<T\\>\" +\n                \" since it would require destroying the underlying array to remove the item.\");\n        };\n        Queue.prototype.dispose = function () {\n            var _ = this;\n            _.clear();\n            if (_._array != emptyArray) {\n                _._array.length = _._capacity = 0;\n                _._array = emptyArray;\n            }\n            _._version = 0;\n        };\n        Queue.prototype.forEach = function (action) {\n            var _ = this, copy = _.toArray(), len = _._size;\n            for (var i = 0; i < len; i++) {\n                if (action(copy[i], i) === false)\n                    break;\n            }\n        };\n        Queue.prototype.setCapacity = function (capacity) {\n            assertIntegerZeroOrGreater(capacity, \"capacity\");\n            var _ = this, array = _._array, len = _._capacity;\n            if (capacity == len)\n                return;\n            var head = _._head, tail = _._tail, size = _._size;\n            if (array != emptyArray && capacity > len && head < tail) {\n                array.length = _._capacity = capacity;\n                _._version++;\n                return;\n            }\n            var newArray = AU.initialize(capacity);\n            if (size > 0) {\n                if (head < tail) {\n                    AU.copyTo(array, newArray, head, 0, size);\n                }\n                else {\n                    AU.copyTo(array, newArray, head, 0, len - head);\n                    AU.copyTo(array, newArray, 0, len - head, tail);\n                }\n            }\n            _._array = newArray;\n            _._capacity = capacity;\n            _._head = 0;\n            _._tail = (size == capacity) ? 0 : size;\n            _._version++;\n        };\n        Queue.prototype.enqueue = function (item) {\n            var _ = this, array = _._array, size = _._size, len = _._capacity;\n            if (size == len) {\n                var newCapacity = len * GROW_FACTOR_HALF;\n                if (newCapacity < len + MINIMUM_GROW)\n                    newCapacity = len + MINIMUM_GROW;\n                _.setCapacity(newCapacity);\n                array = _._array;\n                len = _._capacity;\n            }\n            var tail = _._tail;\n            array[tail] = item;\n            _._tail = (tail + 1) % len;\n            _._size = size + 1;\n            _._version++;\n        };\n        Queue.prototype.dequeue = function (throwIfEmpty) {\n            if (throwIfEmpty === void 0) { throwIfEmpty = false; }\n            var _ = this;\n            if (_._size == 0) {\n                if (throwIfEmpty)\n                    throw new InvalidOperationException_1.default(\"Cannot dequeue an empty queue.\");\n                return void 0;\n            }\n            var array = _._array, head = _._head;\n            var removed = _._array[head];\n            array[head] = null;\n            _._head = (head + 1) % _._capacity;\n            _._size--;\n            if (_._size < _._capacity / 2) {\n                _.trimExcess(SHRINK_THRESHOLD);\n            }\n            _._version++;\n            return removed;\n        };\n        Queue.prototype.tryDequeue = function (out) {\n            if (!this._size)\n                return false;\n            var d = this.dequeue();\n            if (out)\n                out(d);\n            return true;\n        };\n        Queue.prototype._getElement = function (index) {\n            assertIntegerZeroOrGreater(index, \"index\");\n            var _ = this;\n            return _._array[(_._head + index) % _._capacity];\n        };\n        Queue.prototype.peek = function () {\n            if (this._size == 0)\n                throw new InvalidOperationException_1.default(\"Cannot call peek on an empty queue.\");\n            return this._array[this._head];\n        };\n        Queue.prototype.trimExcess = function (threshold) {\n            var _ = this;\n            var size = _._size;\n            if (size < Math.floor(_._capacity * 0.9) && (isNaN(threshold) || threshold < size))\n                _.setCapacity(size);\n        };\n        Queue.prototype.getEnumerator = function () {\n            var _ = this;\n            var index;\n            var version;\n            return new EnumeratorBase_1.default(function () {\n                version = _._version;\n                index = 0;\n            }, function (yielder) {\n                if (version != _._version)\n                    throw new InvalidOperationException_1.default(\"Collection was changed during enumeration.\");\n                if (index == _._size)\n                    return yielder.yieldBreak();\n                return yielder.yieldReturn(_._getElement(index++));\n            });\n        };\n        return Queue;\n    }());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Queue;\n    function assertZeroOrGreater(value, property) {\n        if (value < 0)\n            throw new ArgumentOutOfRangeException_1.default(property, value, \"Must be greater than zero\");\n    }\n    function assertIntegerZeroOrGreater(value, property) {\n        Integer_1.default.assert(value, property);\n        assertZeroOrGreater(value, property);\n    }\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://referencesource.microsoft.com/#System/CompMod/system/collections/generic/queue.cs\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"ICollection.d.ts\"/>\r\n///<reference path=\"IList.d.ts\"/>\r\n///<reference path=\"Enumeration/IEnumerateEach.d.ts\"/>\r\n///<reference path=\"../FunctionTypes.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport * as Values from '../Compare';\r\nimport * as AU from './Array/Utility';\r\nimport Type from '../Types';\r\nimport Integer from '../Integer';\r\nimport EnumeratorBase from './Enumeration/EnumeratorBase';\r\nimport forEach from './Enumeration/forEach';\r\nimport NotImplementedException from '../Exceptions/NotImplementedException';\r\nimport InvalidOperationException from '../Exceptions/InvalidOperationException';\r\nimport ArgumentOutOfRangeException from '../Exceptions/ArgumentOutOfRangeException';\r\n\r\nconst MINIMUM_GROW:number = 4;\r\nconst SHRINK_THRESHOLD:number = 32; // Unused?\r\n// var GROW_FACTOR: number = 200;  // double each time\r\nconst GROW_FACTOR_HALF:number = 100;\r\nconst DEFAULT_CAPACITY:number = MINIMUM_GROW;\r\nvar emptyArray:any[] = [];\r\n\r\nexport default\r\nclass Queue<T> implements ICollection<T>, IEnumerateEach<T>, IDisposable\r\n{\r\n\r\n\tprivate _array:T[];\r\n\tprivate _head:number;       // First valid element in the queue\r\n\tprivate _tail:number;       // Last valid element in the queue\r\n\tprivate _size:number;       // Number of elements.\r\n\tprivate _capacity:number;   // Maps to _array.length;\r\n\tprivate _version:number;\r\n\r\n\r\n\tconstructor(source?:IEnumerable<T> | IArray<T> | number)\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_._head = 0;\r\n\t\t_._tail = 0;\r\n\t\t_._size = 0;\r\n\t\t_._version = 0;\r\n\r\n\t\tif(!source)\r\n\t\t\t_._array = emptyArray;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(Type.isNumber(source))\r\n\t\t\t{\r\n\t\t\t\tvar capacity = <number>source;\r\n\t\t\t\tassertIntegerZeroOrGreater(capacity, \"capacity\");\r\n\r\n\t\t\t\t_._array = capacity\r\n\t\t\t\t\t? AU.initialize<T>(capacity)\r\n\t\t\t\t\t: emptyArray;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar se = <IEnumerable<T> | IArray<T>> source;\r\n\t\t\t\t_._array = AU.initialize<T>(\r\n\t\t\t\t\tType.isArrayLike(se)\r\n\t\t\t\t\t\t? se.length\r\n\t\t\t\t\t\t: DEFAULT_CAPACITY\r\n\t\t\t\t);\r\n\r\n\t\t\t\tforEach<T>(se, (e:T)=> _.enqueue(e));\r\n\r\n\t\t\t\t_._version = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_._capacity = _._array.length;\r\n\t}\r\n\r\n\t// #region ICollection<T> implementation\r\n\r\n\tget count():number\r\n\t{\r\n\t\treturn this._size;\r\n\t}\r\n\r\n\tget isReadOnly():boolean\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tadd(item:T):void\r\n\t{\r\n\t\tthis.enqueue(item);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Clears out the array and returns the number of items that were removed.\r\n\t * @returns {number}\r\n\t */\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, array = _._array, head = _._head, tail = _._tail, size = _._size;\r\n\t\tif(head<tail)\r\n\t\t\tAU.clear(array, head, size);\r\n\t\telse\r\n\t\t{\r\n\t\t\tAU.clear(array, head, array.length - head);\r\n\t\t\tAU.clear(array, 0, tail);\r\n\t\t}\r\n\r\n\t\t_._head = 0;\r\n\t\t_._tail = 0;\r\n\t\t_._size = 0;\r\n\t\t_._version++;\r\n\r\n\t\t_.trimExcess();\r\n\r\n\t\treturn size;\r\n\t}\r\n\r\n\t/**\r\n\t * Dequeues entries into an array.\r\n\t */\r\n\tdump(max:number = Infinity):T[]\r\n\t{\r\n\t\tif(Type.isNumber(max, false) && max<0)\r\n\t\t\tthrow new ArgumentOutOfRangeException('max', max, 'must be greater than or equal to 0.');\r\n\r\n\t\tvar _ = this, result:T[] = [];\r\n\r\n\t\tif(isFinite(max))\r\n\t\t{\r\n\t\t\tInteger.assert(max, 'max');\r\n\t\t\twhile(max-- && _._size)\r\n\t\t\t{\r\n\t\t\t\tresult.push(_.dequeue());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\twhile(_._size)\r\n\t\t\t{\r\n\t\t\t\tresult.push(_.dequeue());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_.trimExcess();\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tcontains(item:T):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar array = _._array, index = _._head, count = _._size, len = _._capacity;\r\n\r\n\t\twhile(count-->0)\r\n\t\t{\r\n\t\t\tif(Values.areEqual(array[index], item)) // May need a equality compare here.\r\n\t\t\t\treturn true;\r\n\r\n\t\t\tindex = (index + 1)%len;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\tcopyTo(target:T[], arrayIndex:number = 0):T[]\r\n\t{\r\n\t\tif(target==null)\r\n\t\t\tthrow new Error(\"ArgumentNullException: array cannot be null.\");\r\n\r\n\t\tassertIntegerZeroOrGreater(arrayIndex, \"arrayIndex\");\r\n\r\n\t\tvar _ = this, size = _._size;\r\n\r\n\t\tif(!size) return;\r\n\r\n\t\tvar numToCopy = size,\r\n\t\t    source    = _._array,\r\n\t\t    len       = _._capacity,\r\n\t\t    head      = _._head,\r\n\t\t    lh        = len - head,\r\n\t\t    firstPart\r\n\t\t              = (lh<size)\r\n\t\t\t    ? lh\r\n\t\t\t    : size;\r\n\r\n\t\tAU.copyTo(source, target, head, arrayIndex, firstPart);\r\n\t\tnumToCopy -= firstPart;\r\n\r\n\t\tif(numToCopy>0)\r\n\t\t\tAU.copyTo(source, target, 0, arrayIndex + len - head, numToCopy);\r\n\r\n\t\treturn target;\r\n\t}\r\n\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tvar _ = this, size = _._size;\r\n\t\tvar arr:T[] = AU.initialize<T>(size);\r\n\t\treturn size ? _.copyTo(arr) : arr;\r\n\t}\r\n\r\n\tremove(item:T):number\r\n\t{\r\n\t\tthrow new NotImplementedException(\r\n\t\t\t\"ICollection\\<T\\>.remove is not implemented in Queue\\<T\\>\" +\r\n\t\t\t\" since it would require destroying the underlying array to remove the item.\"\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t// #endregion\r\n\r\n\t// Results in a complete reset.  Allows for easy cleanup elsewhere.\r\n\tdispose():void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.clear();\r\n\t\tif(_._array!=emptyArray)\r\n\t\t{\r\n\t\t\t_._array.length = _._capacity = 0;\r\n\t\t\t_._array = emptyArray;\r\n\t\t}\r\n\t\t_._version = 0;\r\n\t}\r\n\r\n\r\n\tforEach(action:Predicate<T> | Action<T>):void\r\n\t{\r\n\t\t// Until implementing a changed enumeration mechanism, a copy needs to be used.\r\n\t\tvar _ = this, copy = _.toArray(), len = _._size;\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tif(<any>action(copy[i], i)===false)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tsetCapacity(capacity:number):void\r\n\t{\r\n\r\n\t\tassertIntegerZeroOrGreater(capacity, \"capacity\");\r\n\r\n\t\tvar _ = this, array = _._array, len = _._capacity;\r\n\r\n\t\tif(capacity==len)\r\n\t\t\treturn;\r\n\r\n\t\tvar head = _._head, tail = _._tail, size = _._size;\r\n\r\n\t\t// Special case where we can simply extend the length of the array. (JavaScript only)\r\n\t\tif(array!=emptyArray && capacity>len && head<tail)\r\n\t\t{\r\n\t\t\tarray.length = _._capacity = capacity;\r\n\t\t\t_._version++;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// We create a new array because modifying an existing one could be slow.\r\n\t\tvar newArray:T[] = AU.initialize<T>(capacity);\r\n\t\tif(size>0)\r\n\t\t{\r\n\t\t\tif(head<tail)\r\n\t\t\t{\r\n\t\t\t\tAU.copyTo(array, newArray, head, 0, size);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tAU.copyTo(array, newArray, head, 0, len - head);\r\n\t\t\t\tAU.copyTo(array, newArray, 0, len - head, tail);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_._array = newArray;\r\n\t\t_._capacity = capacity;\r\n\t\t_._head = 0;\r\n\t\t_._tail = (size==capacity) ? 0 : size;\r\n\t\t_._version++;\r\n\t}\r\n\r\n\tenqueue(item:T):void\r\n\t{\r\n\t\tvar _ = this, array = _._array, size = _._size, len = _._capacity;\r\n\t\tif(size==len)\r\n\t\t{\r\n\t\t\tvar newCapacity = len*GROW_FACTOR_HALF;\r\n\t\t\tif(newCapacity<len + MINIMUM_GROW)\r\n\t\t\t\tnewCapacity = len + MINIMUM_GROW;\r\n\r\n\t\t\t_.setCapacity(newCapacity);\r\n\t\t\tarray = _._array;\r\n\t\t\tlen = _._capacity;\r\n\t\t}\r\n\r\n\t\tvar tail = _._tail;\r\n\t\tarray[tail] = item;\r\n\t\t_._tail = (tail + 1)%len;\r\n\t\t_._size = size + 1;\r\n\t\t_._version++;\r\n\t}\r\n\r\n\tdequeue(throwIfEmpty:boolean = false):T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_._size==0)\r\n\t\t{\r\n\t\t\tif(throwIfEmpty)\r\n\t\t\t\tthrow new InvalidOperationException(\"Cannot dequeue an empty queue.\");\r\n\t\t\treturn void 0;\r\n\t\t}\r\n\r\n\t\tvar array = _._array, head = _._head;\r\n\r\n\t\tvar removed = _._array[head];\r\n\t\tarray[head] = null;\r\n\t\t_._head = (head + 1)%_._capacity;\r\n\r\n\t\t_._size--;\r\n\r\n\r\n\t\tif(_._size<_._capacity/2)\r\n\t\t{\r\n\t\t\t_.trimExcess(SHRINK_THRESHOLD);\r\n\t\t}\r\n\r\n\t\t_._version++;\r\n\t\treturn removed;\r\n\t}\r\n\r\n\ttryDequeue(out:(value:T)=>void):boolean\r\n\t{\r\n\t\tif(!this._size) return false;\r\n\t\tvar d = this.dequeue();\r\n\t\tif(out) out(d);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprivate _getElement(index:number):T\r\n\t{\r\n\t\tassertIntegerZeroOrGreater(index, \"index\");\r\n\r\n\t\tvar _ = this;\r\n\t\treturn _._array[(_._head + index)%_._capacity];\r\n\t}\r\n\r\n\tpeek():T\r\n\t{\r\n\t\tif(this._size==0)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot call peek on an empty queue.\");\r\n\r\n\t\treturn this._array[this._head];\r\n\t}\r\n\r\n\ttrimExcess(threshold?:number):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar size = _._size;\r\n\t\tif(size<Math.floor(_._capacity*0.9) && (isNaN(threshold) || threshold<size))\r\n\t\t\t_.setCapacity(size);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar index:number;\r\n\t\tvar version:number;\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tversion = _._version;\r\n\t\t\t\tindex = 0;\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\tif(version!=_._version)\r\n\t\t\t\t\tthrow new InvalidOperationException(\"Collection was changed during enumeration.\");\r\n\r\n\t\t\t\tif(index==_._size)\r\n\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\treturn yielder.yieldReturn(_._getElement(index++));\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction assertZeroOrGreater(value:number, property:string):void\r\n{\r\n\tif(value<0)\r\n\t\tthrow new ArgumentOutOfRangeException(property, value, \"Must be greater than zero\");\r\n\r\n}\r\n\r\nfunction assertIntegerZeroOrGreater(value:number, property:string):void\r\n{\r\n\tInteger.assert(value, property);\r\n\tassertZeroOrGreater(value, property);\r\n}\r\n"]}