{"version":3,"sources":["System/Events/EventDispatcher.js","System/Events/EventDispatcher.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","define","require","exports","shallowCopy_1","DisposableBase_1","AU","DISPOSING","DISPOSED","EventDispatcherEntry","_super","type","listener","useCapture","priority","call","_","dispose","defineProperty","get","enumerable","configurable","matches","equals","other","value","EventDispatcher","apply","arguments","_isDisposing","addEventListener","l","_listeners","push","registerEventListener","hasEventListener","some","removeEventListener","userCapture","i","findIndex","entry","e","splice","dispatchEvent","params","_this","length","event","Event","cancelable","target","entries","forEach","sort","a","newEvent","wasDisposed"],"mappings":"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","file":"System/Events/EventDispatcher.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\ndefine([\"require\", \"exports\", '../Utility/shallowCopy', '../Disposable/DisposableBase', '../Collections/Array/Utility'], function (require, exports, shallowCopy_1, DisposableBase_1, AU) {\n    'use strict';\n    var DISPOSING = 'disposing', DISPOSED = 'disposed';\n    var EventDispatcherEntry = (function (_super) {\n        __extends(EventDispatcherEntry, _super);\n        function EventDispatcherEntry(type, listener, useCapture, priority) {\n            if (useCapture === void 0) { useCapture = false; }\n            if (priority === void 0) { priority = 0; }\n            _super.call(this);\n            this.type = type;\n            this.listener = listener;\n            this.useCapture = useCapture;\n            this.priority = priority;\n            var _ = this;\n            _.type = type;\n            _.listener = listener;\n            _.useCapture = useCapture;\n            _.priority = priority;\n        }\n        EventDispatcherEntry.prototype.dispose = function () {\n            this.listener = null;\n        };\n        Object.defineProperty(EventDispatcherEntry.prototype, \"wasDisposed\", {\n            get: function () {\n                return this.listener == null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        EventDispatcherEntry.prototype.matches = function (type, listener, useCapture) {\n            if (useCapture === void 0) { useCapture = false; }\n            var _ = this;\n            return _.type == type\n                && _.listener == listener\n                && _.useCapture == useCapture;\n        };\n        EventDispatcherEntry.prototype.equals = function (other) {\n            var _ = this;\n            return _.type == other.type\n                && _.listener == other.listener\n                && _.useCapture == other.useCapture\n                && _.priority == other.priority;\n        };\n        return EventDispatcherEntry;\n    }(DisposableBase_1.default));\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = EventDispatcherEntry;\n    var EventDispatcher = (function (_super) {\n        __extends(EventDispatcher, _super);\n        function EventDispatcher() {\n            _super.apply(this, arguments);\n            this._isDisposing = false;\n        }\n        EventDispatcher.prototype.addEventListener = function (type, listener, useCapture, priority) {\n            if (useCapture === void 0) { useCapture = false; }\n            if (priority === void 0) { priority = 0; }\n            var l = this._listeners;\n            if (!l)\n                this._listeners = l = [];\n            l.push(new EventDispatcherEntry(type, listener, useCapture, priority));\n        };\n        EventDispatcher.prototype.registerEventListener = function (type, listener, useCapture, priority) {\n            if (useCapture === void 0) { useCapture = false; }\n            if (priority === void 0) { priority = 0; }\n            if (!this.hasEventListener(type, listener, useCapture))\n                this.addEventListener(type, listener, useCapture, priority);\n        };\n        EventDispatcher.prototype.hasEventListener = function (type, listener, useCapture) {\n            if (useCapture === void 0) { useCapture = false; }\n            var l = this._listeners;\n            return l && l.some(function (value) {\n                return type == value.type && (!listener || listener == value.listener && useCapture == value.useCapture);\n            });\n        };\n        EventDispatcher.prototype.removeEventListener = function (type, listener, userCapture) {\n            if (userCapture === void 0) { userCapture = false; }\n            var l = this._listeners;\n            if (l) {\n                var i = AU.findIndex(l, function (entry) { return entry.matches(type, listener, userCapture); });\n                if (i != -1) {\n                    var e = l[i];\n                    l.splice(i, 1);\n                    e.dispose();\n                }\n            }\n        };\n        EventDispatcher.prototype.dispatchEvent = function (e, params) {\n            var _this = this;\n            var _ = this, l = _._listeners;\n            if (!l || !l.length)\n                return false;\n            var event;\n            if (typeof e == \"string\") {\n                event = Object.create(Event);\n                if (!params)\n                    params = {};\n                event.cancelable = !!params.cancelable;\n                event.target = _;\n                event.type = e;\n            }\n            else\n                event = e;\n            var type = event.type;\n            var entries = [];\n            l.forEach(function (e) { if (e.type == type)\n                entries.push(e); });\n            if (!entries.length)\n                return false;\n            entries.sort(function (a, b) { return b.priority - a.priority; });\n            entries.forEach(function (entry) {\n                var newEvent = Object.create(Event);\n                shallowCopy_1.default(event, newEvent);\n                newEvent.target = _this;\n                entry.listener(newEvent);\n            });\n            return true;\n        };\n        Object.defineProperty(EventDispatcher, \"DISPOSING\", {\n            get: function () { return DISPOSING; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventDispatcher, \"DISPOSED\", {\n            get: function () { return DISPOSED; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventDispatcher.prototype, \"isDisposing\", {\n            get: function () {\n                return this._isDisposing;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        EventDispatcher.prototype.dispose = function () {\n            var _ = this;\n            if (!_.wasDisposed && !_._isDisposing) {\n                _._isDisposing = true;\n                _.dispatchEvent(DISPOSING);\n                _super.prototype.dispose.call(this);\n                _.dispatchEvent(DISPOSED);\n                var l = _._listeners;\n                if (l) {\n                    this._listeners = null;\n                    l.forEach(function (e) { return e.dispose(); });\n                }\n            }\n        };\n        return EventDispatcher;\n    }(DisposableBase_1.default));\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"../Disposable/IDisposable.d.ts\"/>\r\n///<reference path=\"IEventDispatcher.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\n\r\nimport shallowCopy from '../Utility/shallowCopy';\r\nimport DisposableBase from '../Disposable/DisposableBase';\r\nimport * as AU from '../Collections/Array/Utility';\r\n\r\nconst DISPOSING:string = 'disposing',\r\n      DISPOSED:string = 'disposed';\r\n\r\nexport default\r\nclass EventDispatcherEntry extends DisposableBase\r\n{\r\n\r\n\tconstructor(\r\n\t\tpublic type:string,\r\n\t\tpublic listener:EventListener,\r\n\t\tpublic useCapture:boolean = false,\r\n\t\tpublic priority:number = 0)//, useWeakReference: boolean = false)\r\n\t{\r\n\t\tsuper();\r\n\t\tvar _ = this;\r\n\t\t_.type = type;\r\n\t\t_.listener = listener;\r\n\t\t_.useCapture = useCapture;\r\n\t\t_.priority = priority;\r\n\t\t// _.useWeakReference = useWeakReference;\r\n\t}\r\n\r\n\t// useWeakReference: boolean;\r\n\r\n\tdispose():void {\r\n\t\tthis.listener = null;\r\n\t}\r\n\r\n\tget wasDisposed():boolean {\r\n\t\treturn this.listener==null;\r\n\t}\r\n\r\n\tmatches(type:string, listener:EventListener, useCapture:boolean = false):boolean {\r\n\t\tvar _ = this;\r\n\t\treturn _.type==type\r\n\t\t       && _.listener==listener\r\n\t\t       && _.useCapture==useCapture;\r\n\t}\r\n\r\n\tequals(other:EventDispatcherEntry):boolean {\r\n\t\tvar _ = this;\r\n\t\treturn _.type==other.type\r\n\t\t       && _.listener==other.listener\r\n\t\t       && _.useCapture==other.useCapture\r\n\t\t       && _.priority==other.priority\r\n\t\t\t// && this.useWeakReference == other.useWeakReference\r\n\t\t\t;\r\n\t}\r\n}\r\n\r\nclass EventDispatcher extends DisposableBase implements IEventDispatcher\r\n{\r\n\r\n\tprivate _listeners:EventDispatcherEntry[];\r\n\r\n\taddEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:EventListener,\r\n\t\tuseCapture:boolean = false,\r\n\t\tpriority:number = 0):void//, useWeakReference: boolean= false)\r\n\t{\r\n\t\tvar l:EventDispatcherEntry[] = this._listeners;\r\n\t\tif(!l)\r\n\t\t\tthis._listeners = l = [];\r\n\r\n\t\t// flash/vibe.js means of adding is indiscriminate and will double add listeners...\r\n\t\t// we can then avoid double adds by including a 'registerEventListener' method.\r\n\t\tl.push(new EventDispatcherEntry(type, listener, useCapture, priority));//, useWeakReference));\r\n\t}\r\n\r\n\t// Allow for simple add once mechanism.\r\n\tregisterEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:EventListener,\r\n\t\tuseCapture:boolean = false,\r\n\t\tpriority:number = 0):void//, useWeakReference: boolean= false)\r\n\t{\r\n\t\tif(!this.hasEventListener(type, listener, useCapture))\r\n\t\t\tthis.addEventListener(type, listener, useCapture, priority);\r\n\t}\r\n\r\n\thasEventListener(type:string, listener?:EventListener, useCapture:boolean = false):boolean {\r\n\t\tvar l = this._listeners;\r\n\t\treturn l && l.some(\r\n\t\t\t\t(value:EventDispatcherEntry):boolean =>\r\n               type==value.type && (!listener || listener==value.listener && useCapture==value.useCapture)\r\n\t\t\t);\r\n\r\n\t}\r\n\r\n\tremoveEventListener(type:string, listener:EventListener, userCapture:boolean = false):void {\r\n\r\n\t\tvar l = this._listeners;\r\n\r\n\t\tif(l) {\r\n\t\t\tvar i = AU.findIndex(l, entry=> entry.matches(type, listener, userCapture));\r\n\t\t\tif(i!= -1) {\r\n\t\t\t\tvar e = l[i];\r\n\t\t\t\tl.splice(i, 1);\r\n\t\t\t\te.dispose();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdispatchEvent(type:string, params?:any):boolean;\r\n\tdispatchEvent(event:Event):boolean;\r\n\tdispatchEvent(e:any, params?:any):boolean {\r\n\r\n\t\tvar _ = this, l = _._listeners;\r\n\t\tif(!l || !l.length)\r\n\t\t\treturn false;\r\n\r\n\t\tvar event:Event;\r\n\r\n\t\tif(typeof e==\"string\") {\r\n\t\t\tevent = Object.create(Event);\r\n\t\t\tif(!params)\r\n\t\t\t\tparams = {};\r\n\t\t\tevent.cancelable = !!params.cancelable;\r\n\t\t\tevent.target = _;\r\n\t\t\tevent.type = e;\r\n\t\t}\r\n\t\telse\r\n\t\t\tevent = <Event>e;\r\n\r\n\t\tvar type = event.type;\r\n\r\n\t\t// noinspection JSMismatchedCollectionQueryUpdate\r\n\t\tvar entries:EventDispatcherEntry[] = [];//, propagate = true, prevent = false;\r\n\t\tl.forEach((e:EventDispatcherEntry):void => { if(e.type==type) entries.push(e); });\r\n\t\tif(!entries.length)\r\n\t\t\treturn false;\r\n\r\n\t\tentries.sort(function (a, b) { return b.priority - a.priority; });\r\n\r\n\t\t// For now... Just use simple...\r\n\t\tentries.forEach(\r\n\t\t\t\tentry=> {\r\n\t\t\t\tvar newEvent = Object.create(Event);\r\n\t\t\t\tshallowCopy(event, newEvent);\r\n\t\t\t\tnewEvent.target = this;\r\n\t\t\t\tentry.listener(newEvent);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tstatic get DISPOSING() { return DISPOSING; }\r\n\r\n\tstatic get DISPOSED() { return DISPOSED; }\r\n\r\n\t// When dispatching events, we need a way to prevent recursion when disposing.\r\n\tprivate _isDisposing:boolean = false;\r\n\tget isDisposing():boolean {\r\n\t\treturn this._isDisposing;\r\n\t}\r\n\r\n\t// Override the public method here since EventDispatcher will end up doing things a bit differently from here on.\r\n\tpublic dispose() {\r\n\r\n\t\t// Having a disposing event can allow for child objects to automatically release themselves when their parent is disposed.\r\n\t\tvar _ = this;\r\n\t\tif(!_.wasDisposed && !_._isDisposing) {\r\n\t\t\t_._isDisposing = true;\r\n\t\t\t_.dispatchEvent(DISPOSING);\r\n\r\n\t\t\tsuper.dispose();\r\n\r\n\t\t\t_.dispatchEvent(DISPOSED);\r\n\r\n\t\t\tvar l = _._listeners;\r\n\t\t\tif(l) {\r\n\t\t\t\tthis._listeners = null;\r\n\t\t\t\tl.forEach(e=> e.dispose());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n"]}