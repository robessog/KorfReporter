{"version":3,"sources":["System/Events/EventDispatcher.ts","System/Events/EventDispatcher.js"],"names":[],"mappings":"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","file":"System/Events/EventDispatcher.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"../Disposable/IDisposable.d.ts\"/>\r\n///<reference path=\"IEventDispatcher.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\n\r\nimport shallowCopy from '../Utility/shallowCopy';\r\nimport DisposableBase from '../Disposable/DisposableBase';\r\nimport * as AU from '../Collections/Array/Utility';\r\n\r\nconst DISPOSING:string = 'disposing',\r\n      DISPOSED:string = 'disposed';\r\n\r\nexport default\r\nclass EventDispatcherEntry extends DisposableBase\r\n{\r\n\r\n\tconstructor(\r\n\t\tpublic type:string,\r\n\t\tpublic listener:EventListener,\r\n\t\tpublic useCapture:boolean = false,\r\n\t\tpublic priority:number = 0)//, useWeakReference: boolean = false)\r\n\t{\r\n\t\tsuper();\r\n\t\tvar _ = this;\r\n\t\t_.type = type;\r\n\t\t_.listener = listener;\r\n\t\t_.useCapture = useCapture;\r\n\t\t_.priority = priority;\r\n\t\t// _.useWeakReference = useWeakReference;\r\n\t}\r\n\r\n\t// useWeakReference: boolean;\r\n\r\n\tdispose():void {\r\n\t\tthis.listener = null;\r\n\t}\r\n\r\n\tget wasDisposed():boolean {\r\n\t\treturn this.listener==null;\r\n\t}\r\n\r\n\tmatches(type:string, listener:EventListener, useCapture:boolean = false):boolean {\r\n\t\tvar _ = this;\r\n\t\treturn _.type==type\r\n\t\t       && _.listener==listener\r\n\t\t       && _.useCapture==useCapture;\r\n\t}\r\n\r\n\tequals(other:EventDispatcherEntry):boolean {\r\n\t\tvar _ = this;\r\n\t\treturn _.type==other.type\r\n\t\t       && _.listener==other.listener\r\n\t\t       && _.useCapture==other.useCapture\r\n\t\t       && _.priority==other.priority\r\n\t\t\t// && this.useWeakReference == other.useWeakReference\r\n\t\t\t;\r\n\t}\r\n}\r\n\r\nclass EventDispatcher extends DisposableBase implements IEventDispatcher\r\n{\r\n\r\n\tprivate _listeners:EventDispatcherEntry[];\r\n\r\n\taddEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:EventListener,\r\n\t\tuseCapture:boolean = false,\r\n\t\tpriority:number = 0):void//, useWeakReference: boolean= false)\r\n\t{\r\n\t\tvar l:EventDispatcherEntry[] = this._listeners;\r\n\t\tif(!l)\r\n\t\t\tthis._listeners = l = [];\r\n\r\n\t\t// flash/vibe.js means of adding is indiscriminate and will double add listeners...\r\n\t\t// we can then avoid double adds by including a 'registerEventListener' method.\r\n\t\tl.push(new EventDispatcherEntry(type, listener, useCapture, priority));//, useWeakReference));\r\n\t}\r\n\r\n\t// Allow for simple add once mechanism.\r\n\tregisterEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:EventListener,\r\n\t\tuseCapture:boolean = false,\r\n\t\tpriority:number = 0):void//, useWeakReference: boolean= false)\r\n\t{\r\n\t\tif(!this.hasEventListener(type, listener, useCapture))\r\n\t\t\tthis.addEventListener(type, listener, useCapture, priority);\r\n\t}\r\n\r\n\thasEventListener(type:string, listener?:EventListener, useCapture:boolean = false):boolean {\r\n\t\tvar l = this._listeners;\r\n\t\treturn l && l.some(\r\n\t\t\t\t(value:EventDispatcherEntry):boolean =>\r\n               type==value.type && (!listener || listener==value.listener && useCapture==value.useCapture)\r\n\t\t\t);\r\n\r\n\t}\r\n\r\n\tremoveEventListener(type:string, listener:EventListener, userCapture:boolean = false):void {\r\n\r\n\t\tvar l = this._listeners;\r\n\r\n\t\tif(l) {\r\n\t\t\tvar i = AU.findIndex(l, entry=> entry.matches(type, listener, userCapture));\r\n\t\t\tif(i!= -1) {\r\n\t\t\t\tvar e = l[i];\r\n\t\t\t\tl.splice(i, 1);\r\n\t\t\t\te.dispose();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdispatchEvent(type:string, params?:any):boolean;\r\n\tdispatchEvent(event:Event):boolean;\r\n\tdispatchEvent(e:any, params?:any):boolean {\r\n\r\n\t\tvar _ = this, l = _._listeners;\r\n\t\tif(!l || !l.length)\r\n\t\t\treturn false;\r\n\r\n\t\tvar event:Event;\r\n\r\n\t\tif(typeof e==\"string\") {\r\n\t\t\tevent = Object.create(Event);\r\n\t\t\tif(!params)\r\n\t\t\t\tparams = {};\r\n\t\t\tevent.cancelable = !!params.cancelable;\r\n\t\t\tevent.target = _;\r\n\t\t\tevent.type = e;\r\n\t\t}\r\n\t\telse\r\n\t\t\tevent = <Event>e;\r\n\r\n\t\tvar type = event.type;\r\n\r\n\t\t// noinspection JSMismatchedCollectionQueryUpdate\r\n\t\tvar entries:EventDispatcherEntry[] = [];//, propagate = true, prevent = false;\r\n\t\tl.forEach((e:EventDispatcherEntry):void => { if(e.type==type) entries.push(e); });\r\n\t\tif(!entries.length)\r\n\t\t\treturn false;\r\n\r\n\t\tentries.sort(function (a, b) { return b.priority - a.priority; });\r\n\r\n\t\t// For now... Just use simple...\r\n\t\tentries.forEach(\r\n\t\t\t\tentry=> {\r\n\t\t\t\tvar newEvent = Object.create(Event);\r\n\t\t\t\tshallowCopy(event, newEvent);\r\n\t\t\t\tnewEvent.target = this;\r\n\t\t\t\tentry.listener(newEvent);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tstatic get DISPOSING() { return DISPOSING; }\r\n\r\n\tstatic get DISPOSED() { return DISPOSED; }\r\n\r\n\t// When dispatching events, we need a way to prevent recursion when disposing.\r\n\tprivate _isDisposing:boolean = false;\r\n\tget isDisposing():boolean {\r\n\t\treturn this._isDisposing;\r\n\t}\r\n\r\n\t// Override the public method here since EventDispatcher will end up doing things a bit differently from here on.\r\n\tpublic dispose() {\r\n\r\n\t\t// Having a disposing event can allow for child objects to automatically release themselves when their parent is disposed.\r\n\t\tvar _ = this;\r\n\t\tif(!_.wasDisposed && !_._isDisposing) {\r\n\t\t\t_._isDisposing = true;\r\n\t\t\t_.dispatchEvent(DISPOSING);\r\n\r\n\t\t\tsuper.dispose();\r\n\r\n\t\t\t_.dispatchEvent(DISPOSED);\r\n\r\n\t\t\tvar l = _._listeners;\r\n\t\t\tif(l) {\r\n\t\t\t\tthis._listeners = null;\r\n\t\t\t\tl.forEach(e=> e.dispose());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n","/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n'use strict';\nconst shallowCopy_1 = require('../Utility/shallowCopy');\nconst DisposableBase_1 = require('../Disposable/DisposableBase');\nconst AU = require('../Collections/Array/Utility');\nconst DISPOSING = 'disposing', DISPOSED = 'disposed';\nclass EventDispatcherEntry extends DisposableBase_1.default {\n    constructor(type, listener, useCapture = false, priority = 0) {\n        super();\n        this.type = type;\n        this.listener = listener;\n        this.useCapture = useCapture;\n        this.priority = priority;\n        var _ = this;\n        _.type = type;\n        _.listener = listener;\n        _.useCapture = useCapture;\n        _.priority = priority;\n    }\n    dispose() {\n        this.listener = null;\n    }\n    get wasDisposed() {\n        return this.listener == null;\n    }\n    matches(type, listener, useCapture = false) {\n        var _ = this;\n        return _.type == type\n            && _.listener == listener\n            && _.useCapture == useCapture;\n    }\n    equals(other) {\n        var _ = this;\n        return _.type == other.type\n            && _.listener == other.listener\n            && _.useCapture == other.useCapture\n            && _.priority == other.priority;\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EventDispatcherEntry;\nclass EventDispatcher extends DisposableBase_1.default {\n    constructor(...args) {\n        super(...args);\n        this._isDisposing = false;\n    }\n    addEventListener(type, listener, useCapture = false, priority = 0) {\n        var l = this._listeners;\n        if (!l)\n            this._listeners = l = [];\n        l.push(new EventDispatcherEntry(type, listener, useCapture, priority));\n    }\n    registerEventListener(type, listener, useCapture = false, priority = 0) {\n        if (!this.hasEventListener(type, listener, useCapture))\n            this.addEventListener(type, listener, useCapture, priority);\n    }\n    hasEventListener(type, listener, useCapture = false) {\n        var l = this._listeners;\n        return l && l.some((value) => type == value.type && (!listener || listener == value.listener && useCapture == value.useCapture));\n    }\n    removeEventListener(type, listener, userCapture = false) {\n        var l = this._listeners;\n        if (l) {\n            var i = AU.findIndex(l, entry => entry.matches(type, listener, userCapture));\n            if (i != -1) {\n                var e = l[i];\n                l.splice(i, 1);\n                e.dispose();\n            }\n        }\n    }\n    dispatchEvent(e, params) {\n        var _ = this, l = _._listeners;\n        if (!l || !l.length)\n            return false;\n        var event;\n        if (typeof e == \"string\") {\n            event = Object.create(Event);\n            if (!params)\n                params = {};\n            event.cancelable = !!params.cancelable;\n            event.target = _;\n            event.type = e;\n        }\n        else\n            event = e;\n        var type = event.type;\n        var entries = [];\n        l.forEach((e) => { if (e.type == type)\n            entries.push(e); });\n        if (!entries.length)\n            return false;\n        entries.sort(function (a, b) { return b.priority - a.priority; });\n        entries.forEach(entry => {\n            var newEvent = Object.create(Event);\n            shallowCopy_1.default(event, newEvent);\n            newEvent.target = this;\n            entry.listener(newEvent);\n        });\n        return true;\n    }\n    static get DISPOSING() { return DISPOSING; }\n    static get DISPOSED() { return DISPOSED; }\n    get isDisposing() {\n        return this._isDisposing;\n    }\n    dispose() {\n        var _ = this;\n        if (!_.wasDisposed && !_._isDisposing) {\n            _._isDisposing = true;\n            _.dispatchEvent(DISPOSING);\n            super.dispose();\n            _.dispatchEvent(DISPOSED);\n            var l = _._listeners;\n            if (l) {\n                this._listeners = null;\n                l.forEach(e => e.dispose());\n            }\n        }\n    }\n}\n"]}