{"version":3,"sources":["System/Tasks/TaskScheduler.js","System/Tasks/TaskScheduler.ts"],"names":[],"mappings":"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","file":"System/Tasks/TaskScheduler.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Based on code from: https://github.com/kriskowal/q\n */\n\"use strict\";\nconst Types_1 = require('../Types');\nconst LinkedList_1 = require(\"../Collections/LinkedList\");\nconst Queue_1 = require(\"../Collections/Queue\");\n\"use strict\";\nvar requestTick;\nvar isNodeJS = false;\nvar flushing = false;\nfunction flush() {\n    var entry;\n    while (entry = immediateQueue.first) {\n        let e = entry.value, domain = e.domain;\n        entry.remove();\n        if (domain)\n            domain.enter();\n        runSingle(e.task, domain);\n    }\n    var task;\n    while (task = laterQueue.dequeue()) {\n        runSingle(task);\n    }\n    flushing = false;\n}\nvar immediateQueue = new LinkedList_1.default();\nvar laterQueue = new Queue_1.default();\nfunction runSingle(task, domain) {\n    try {\n        task();\n    }\n    catch (e) {\n        if (isNodeJS) {\n            if (domain) {\n                domain.exit();\n            }\n            setTimeout(flush, 0);\n            if (domain) {\n                domain.enter();\n            }\n            throw e;\n        }\n        else {\n            setTimeout(() => {\n                throw e;\n            }, 0);\n        }\n    }\n    if (domain) {\n        domain.exit();\n    }\n}\nfunction requestFlush() {\n    if (!flushing) {\n        flushing = true;\n        requestTick();\n    }\n}\nvar TaskScheduler;\n(function (TaskScheduler) {\n    function defer(task, delay) {\n        if (Types_1.default.isNumber(delay, false) && delay >= 0) {\n            var timeout = 0;\n            var cancel = () => {\n                if (timeout) {\n                    clearTimeout(timeout);\n                    timeout = 0;\n                    return true;\n                }\n                return false;\n            };\n            timeout = setTimeout(() => {\n                cancel();\n                task();\n            }, delay);\n            return cancel;\n        }\n        var entry = {\n            task: task,\n            domain: isNodeJS && process['domain']\n        };\n        immediateQueue.add(entry);\n        requestFlush();\n        return () => !!immediateQueue.remove(entry);\n    }\n    TaskScheduler.defer = defer;\n    function runAfterDeferred(task) {\n        laterQueue.enqueue(task);\n        requestFlush();\n    }\n    TaskScheduler.runAfterDeferred = runAfterDeferred;\n})(TaskScheduler || (TaskScheduler = {}));\nif (Types_1.default.isObject(process)\n    && process.toString() === \"[object process]\"\n    && process.nextTick) {\n    isNodeJS = true;\n    requestTick = () => {\n        process.nextTick(flush);\n    };\n}\nelse if (typeof setImmediate === \"function\") {\n    if (typeof window !== \"undefined\") {\n        requestTick = setImmediate.bind(window, flush);\n    }\n    else {\n        requestTick = () => {\n            setImmediate(flush);\n        };\n    }\n}\nelse if (typeof MessageChannel !== \"undefined\") {\n    var channel = new MessageChannel();\n    channel.port1.onmessage = function () {\n        requestTick = requestPortTick;\n        channel.port1.onmessage = flush;\n        flush();\n    };\n    var requestPortTick = () => {\n        channel.port2.postMessage(0);\n    };\n    requestTick = () => {\n        setTimeout(flush, 0);\n        requestPortTick();\n    };\n}\nelse {\n    requestTick = () => {\n        setTimeout(flush, 0);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = TaskScheduler;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on code from: https://github.com/kriskowal/q\r\n */\r\n\r\nimport Type from '../Types';\r\nimport LinkedList from \"../Collections/LinkedList\";\r\nimport Queue from \"../Collections/Queue\";\r\n\r\ndeclare module process\r\n{\r\n\texport function nextTick(callback:Function):void;\r\n\texport function toString():string;\r\n}\r\n\r\ninterface IDomain\r\n{\r\n\tenter():void;\r\n\texit():void;\r\n}\r\n\r\ninterface TaskQueueEntry\r\n{\r\n\ttask:Function;\r\n\tdomain?:IDomain;\r\n}\r\n\r\n\r\n\"use strict\";\r\n\r\nvar requestTick:()=>void;\r\nvar isNodeJS:boolean = false;\r\nvar flushing:boolean = false;\r\n\r\n// Use the fastest possible means to execute a task in a future turn\r\n// of the event loop.\r\n\r\n\r\n\r\nfunction flush():void\r\n{\r\n\t/* jshint loopfunc: true */\r\n\tvar entry:ILinkedListNode<TaskQueueEntry>;\r\n\r\n\twhile(entry = immediateQueue.first)\r\n\t{\r\n\t\tlet e = entry.value, domain = e.domain;\r\n\t\tentry.remove();\r\n\t\tif(domain) domain.enter();\r\n\t\trunSingle(e.task, domain);\r\n\t}\r\n\r\n\tvar task:Function;\r\n\twhile(task = laterQueue.dequeue())\r\n\t{\r\n\t\trunSingle(task);\r\n\t}\r\n\r\n\tflushing = false;\r\n}\r\n\r\n\r\n// linked list of tasks.  Using a real linked list to allow for removal.\r\nvar immediateQueue:LinkedList<TaskQueueEntry> = new LinkedList<TaskQueueEntry>();\r\n\r\n// queue for late tasks, used by unhandled rejection tracking\r\nvar laterQueue:Queue<Function> = new Queue<Function>();\r\n\r\nfunction runSingle(task:Function, domain?:IDomain):void\r\n{\r\n\ttry\r\n\t{\r\n\t\ttask();\r\n\r\n\t}\r\n\tcatch(e)\r\n\t{\r\n\t\tif(isNodeJS)\r\n\t\t{\r\n\t\t\t// In node, uncaught exceptions are considered fatal errors.\r\n\t\t\t// Re-throw them synchronously to interrupt flushing!\r\n\r\n\t\t\t// Ensure continuation if the uncaught exception is suppressed\r\n\t\t\t// listening \"uncaughtException\" events (as domains does).\r\n\t\t\t// Continue in next event to avoid tick recursion.\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.exit();\r\n\t\t\t}\r\n\t\t\tsetTimeout(flush, 0);\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.enter();\r\n\t\t\t}\r\n\r\n\t\t\tthrow e;\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// In browsers, uncaught exceptions are not fatal.\r\n\t\t\t// Re-throw them asynchronously to avoid slow-downs.\r\n\t\t\tsetTimeout(()=>\r\n\t\t\t{\r\n\t\t\t\tthrow e;\r\n\t\t\t}, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tif(domain)\r\n\t{\r\n\t\tdomain.exit();\r\n\t}\r\n}\r\n\r\nfunction requestFlush():void {\r\n\tif(!flushing)\r\n\t{\r\n\t\tflushing = true;\r\n\t\trequestTick();\r\n\t}\r\n}\r\n\r\nmodule TaskScheduler {\r\n\r\n\r\n\texport function defer(task:Function, delay?:number):()=>boolean\r\n\t{\r\n\t\tif(Type.isNumber(delay,false) && delay>=0) {\r\n\r\n\t\t\tvar timeout:number = 0;\r\n\r\n\t\t\tvar cancel = ()=>{\r\n\t\t\t\tif(timeout) {\r\n\t\t\t\t\tclearTimeout(timeout);\r\n\t\t\t\t\ttimeout = 0;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\r\n\t\t\ttimeout = setTimeout(()=>{\r\n\t\t\t\tcancel();\r\n\t\t\t\ttask();\r\n\t\t\t},delay);\r\n\r\n\t\t\treturn cancel;\r\n\t\t}\r\n\r\n\t\tvar entry = {\r\n\t\t\ttask:task,\r\n\t\t\tdomain:isNodeJS && (<any>process)['domain']\r\n\t\t};\r\n\r\n\t\timmediateQueue.add(entry);\r\n\r\n\t\trequestFlush();\r\n\r\n\t\treturn ()=>!!immediateQueue.remove(entry)\r\n\t}\r\n\r\n\r\n\t// runs a task after all other tasks have been run\r\n\t// this is useful for unhandled rejection tracking that needs to happen\r\n\t// after all `then`d tasks have been run.\r\n\texport function runAfterDeferred(task:Function):void\r\n\t{\r\n\t\tlaterQueue.enqueue(task);\r\n\t\trequestFlush();\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nif(Type.isObject(process)\r\n\t&& process.toString()===\"[object process]\"\r\n\t&& process.nextTick)\r\n{\r\n\t// Ensure Q is in a real Node environment, with a `process.nextTick`.\r\n\t// To see through fake Node environments:\r\n\t// * Mocha test runner - exposes a `process` global without a `nextTick`\r\n\t// * Browserify - exposes a `process.nexTick` function that uses\r\n\t//   `setTimeout`. In this case `setImmediate` is preferred because\r\n\t//    it is faster. Browserify's `process.toString()` yields\r\n\t//   \"[object Object]\", while in a real Node environment\r\n\t//   `process.nextTick()` yields \"[object process]\".\r\n\tisNodeJS = true;\r\n\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tprocess.nextTick(flush);\r\n\t};\r\n\r\n}\r\nelse if(typeof setImmediate===\"function\")\r\n{\r\n\t// In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\r\n\tif(typeof window!==\"undefined\")\r\n\t{\r\n\t\trequestTick = setImmediate.bind(window, flush);\r\n\t}\r\n\telse\r\n\t{\r\n\t\trequestTick = ()=>\r\n\t\t{\r\n\t\t\tsetImmediate(flush);\r\n\t\t};\r\n\t}\r\n\r\n}\r\nelse if(typeof MessageChannel!==\"undefined\")\r\n{\r\n\t// modern browsers\r\n\t// http://www.nonblocking.io/2011/06/windownexttick.html\r\n\tvar channel = new MessageChannel();\r\n\t// At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\r\n\t// working message ports the first time a page loads.\r\n\tchannel.port1.onmessage = function()\r\n\t{\r\n\t\trequestTick = requestPortTick;\r\n\t\tchannel.port1.onmessage = flush;\r\n\t\tflush();\r\n\t};\r\n\tvar requestPortTick = ()=>\r\n\t{\r\n\t\t// Opera requires us to provide a message payload, regardless of\r\n\t\t// whether we use it.\r\n\t\tchannel.port2.postMessage(0);\r\n\t};\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t\trequestPortTick();\r\n\t};\r\n\r\n}\r\nelse\r\n{\r\n\t// old browsers\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t};\r\n}\r\n\r\nexport default TaskScheduler;\r\n"]}