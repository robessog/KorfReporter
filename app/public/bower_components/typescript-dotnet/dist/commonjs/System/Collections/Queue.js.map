{"version":3,"sources":["System/Collections/Queue.ts","System/Collections/Queue.js"],"names":[],"mappings":"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","file":"System/Collections/Queue.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://referencesource.microsoft.com/#System/CompMod/system/collections/generic/queue.cs\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"ICollection.d.ts\"/>\r\n///<reference path=\"IList.d.ts\"/>\r\n///<reference path=\"Enumeration/IEnumerateEach.d.ts\"/>\r\n///<reference path=\"../FunctionTypes.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport * as Values from '../Compare';\r\nimport * as AU from './Array/Utility';\r\nimport Type from '../Types';\r\nimport Integer from '../Integer';\r\nimport EnumeratorBase from './Enumeration/EnumeratorBase';\r\nimport forEach from './Enumeration/forEach';\r\nimport NotImplementedException from '../Exceptions/NotImplementedException';\r\nimport InvalidOperationException from '../Exceptions/InvalidOperationException';\r\nimport ArgumentOutOfRangeException from '../Exceptions/ArgumentOutOfRangeException';\r\n\r\nconst MINIMUM_GROW:number = 4;\r\nconst SHRINK_THRESHOLD:number = 32; // Unused?\r\n// var GROW_FACTOR: number = 200;  // double each time\r\nconst GROW_FACTOR_HALF:number = 100;\r\nconst DEFAULT_CAPACITY:number = MINIMUM_GROW;\r\nvar emptyArray:any[] = [];\r\n\r\nexport default\r\nclass Queue<T> implements ICollection<T>, IEnumerateEach<T>, IDisposable\r\n{\r\n\r\n\tprivate _array:T[];\r\n\tprivate _head:number;       // First valid element in the queue\r\n\tprivate _tail:number;       // Last valid element in the queue\r\n\tprivate _size:number;       // Number of elements.\r\n\tprivate _capacity:number;   // Maps to _array.length;\r\n\tprivate _version:number;\r\n\r\n\r\n\tconstructor(source?:IEnumerable<T> | IArray<T> | number)\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_._head = 0;\r\n\t\t_._tail = 0;\r\n\t\t_._size = 0;\r\n\t\t_._version = 0;\r\n\r\n\t\tif(!source)\r\n\t\t\t_._array = emptyArray;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(Type.isNumber(source))\r\n\t\t\t{\r\n\t\t\t\tvar capacity = <number>source;\r\n\t\t\t\tassertIntegerZeroOrGreater(capacity, \"capacity\");\r\n\r\n\t\t\t\t_._array = capacity\r\n\t\t\t\t\t? AU.initialize<T>(capacity)\r\n\t\t\t\t\t: emptyArray;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar se = <IEnumerable<T> | IArray<T>> source;\r\n\t\t\t\t_._array = AU.initialize<T>(\r\n\t\t\t\t\tType.isArrayLike(se)\r\n\t\t\t\t\t\t? se.length\r\n\t\t\t\t\t\t: DEFAULT_CAPACITY\r\n\t\t\t\t);\r\n\r\n\t\t\t\tforEach<T>(se, (e:T)=> _.enqueue(e));\r\n\r\n\t\t\t\t_._version = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_._capacity = _._array.length;\r\n\t}\r\n\r\n\t// #region ICollection<T> implementation\r\n\r\n\tget count():number\r\n\t{\r\n\t\treturn this._size;\r\n\t}\r\n\r\n\tget isReadOnly():boolean\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tadd(item:T):void\r\n\t{\r\n\t\tthis.enqueue(item);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Clears out the array and returns the number of items that were removed.\r\n\t * @returns {number}\r\n\t */\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, array = _._array, head = _._head, tail = _._tail, size = _._size;\r\n\t\tif(head<tail)\r\n\t\t\tAU.clear(array, head, size);\r\n\t\telse\r\n\t\t{\r\n\t\t\tAU.clear(array, head, array.length - head);\r\n\t\t\tAU.clear(array, 0, tail);\r\n\t\t}\r\n\r\n\t\t_._head = 0;\r\n\t\t_._tail = 0;\r\n\t\t_._size = 0;\r\n\t\t_._version++;\r\n\r\n\t\t_.trimExcess();\r\n\r\n\t\treturn size;\r\n\t}\r\n\r\n\t/**\r\n\t * Dequeues entries into an array.\r\n\t */\r\n\tdump(max:number = Infinity):T[]\r\n\t{\r\n\t\tif(Type.isNumber(max, false) && max<0)\r\n\t\t\tthrow new ArgumentOutOfRangeException('max', max, 'must be greater than or equal to 0.');\r\n\r\n\t\tvar _ = this, result:T[] = [];\r\n\r\n\t\tif(isFinite(max))\r\n\t\t{\r\n\t\t\tInteger.assert(max, 'max');\r\n\t\t\twhile(max-- && _._size)\r\n\t\t\t{\r\n\t\t\t\tresult.push(_.dequeue());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\twhile(_._size)\r\n\t\t\t{\r\n\t\t\t\tresult.push(_.dequeue());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_.trimExcess();\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tcontains(item:T):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar array = _._array, index = _._head, count = _._size, len = _._capacity;\r\n\r\n\t\twhile(count-->0)\r\n\t\t{\r\n\t\t\tif(Values.areEqual(array[index], item)) // May need a equality compare here.\r\n\t\t\t\treturn true;\r\n\r\n\t\t\tindex = (index + 1)%len;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\tcopyTo(target:T[], arrayIndex:number = 0):T[]\r\n\t{\r\n\t\tif(target==null)\r\n\t\t\tthrow new Error(\"ArgumentNullException: array cannot be null.\");\r\n\r\n\t\tassertIntegerZeroOrGreater(arrayIndex, \"arrayIndex\");\r\n\r\n\t\tvar _ = this, size = _._size;\r\n\r\n\t\tif(!size) return;\r\n\r\n\t\tvar numToCopy = size,\r\n\t\t    source    = _._array,\r\n\t\t    len       = _._capacity,\r\n\t\t    head      = _._head,\r\n\t\t    lh        = len - head,\r\n\t\t    firstPart\r\n\t\t              = (lh<size)\r\n\t\t\t    ? lh\r\n\t\t\t    : size;\r\n\r\n\t\tAU.copyTo(source, target, head, arrayIndex, firstPart);\r\n\t\tnumToCopy -= firstPart;\r\n\r\n\t\tif(numToCopy>0)\r\n\t\t\tAU.copyTo(source, target, 0, arrayIndex + len - head, numToCopy);\r\n\r\n\t\treturn target;\r\n\t}\r\n\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tvar _ = this, size = _._size;\r\n\t\tvar arr:T[] = AU.initialize<T>(size);\r\n\t\treturn size ? _.copyTo(arr) : arr;\r\n\t}\r\n\r\n\tremove(item:T):number\r\n\t{\r\n\t\tthrow new NotImplementedException(\r\n\t\t\t\"ICollection\\<T\\>.remove is not implemented in Queue\\<T\\>\" +\r\n\t\t\t\" since it would require destroying the underlying array to remove the item.\"\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t// #endregion\r\n\r\n\t// Results in a complete reset.  Allows for easy cleanup elsewhere.\r\n\tdispose():void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.clear();\r\n\t\tif(_._array!=emptyArray)\r\n\t\t{\r\n\t\t\t_._array.length = _._capacity = 0;\r\n\t\t\t_._array = emptyArray;\r\n\t\t}\r\n\t\t_._version = 0;\r\n\t}\r\n\r\n\r\n\tforEach(action:Predicate<T> | Action<T>):void\r\n\t{\r\n\t\t// Until implementing a changed enumeration mechanism, a copy needs to be used.\r\n\t\tvar _ = this, copy = _.toArray(), len = _._size;\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tif(<any>action(copy[i], i)===false)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tsetCapacity(capacity:number):void\r\n\t{\r\n\r\n\t\tassertIntegerZeroOrGreater(capacity, \"capacity\");\r\n\r\n\t\tvar _ = this, array = _._array, len = _._capacity;\r\n\r\n\t\tif(capacity==len)\r\n\t\t\treturn;\r\n\r\n\t\tvar head = _._head, tail = _._tail, size = _._size;\r\n\r\n\t\t// Special case where we can simply extend the length of the array. (JavaScript only)\r\n\t\tif(array!=emptyArray && capacity>len && head<tail)\r\n\t\t{\r\n\t\t\tarray.length = _._capacity = capacity;\r\n\t\t\t_._version++;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// We create a new array because modifying an existing one could be slow.\r\n\t\tvar newArray:T[] = AU.initialize<T>(capacity);\r\n\t\tif(size>0)\r\n\t\t{\r\n\t\t\tif(head<tail)\r\n\t\t\t{\r\n\t\t\t\tAU.copyTo(array, newArray, head, 0, size);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tAU.copyTo(array, newArray, head, 0, len - head);\r\n\t\t\t\tAU.copyTo(array, newArray, 0, len - head, tail);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_._array = newArray;\r\n\t\t_._capacity = capacity;\r\n\t\t_._head = 0;\r\n\t\t_._tail = (size==capacity) ? 0 : size;\r\n\t\t_._version++;\r\n\t}\r\n\r\n\tenqueue(item:T):void\r\n\t{\r\n\t\tvar _ = this, array = _._array, size = _._size, len = _._capacity;\r\n\t\tif(size==len)\r\n\t\t{\r\n\t\t\tvar newCapacity = len*GROW_FACTOR_HALF;\r\n\t\t\tif(newCapacity<len + MINIMUM_GROW)\r\n\t\t\t\tnewCapacity = len + MINIMUM_GROW;\r\n\r\n\t\t\t_.setCapacity(newCapacity);\r\n\t\t\tarray = _._array;\r\n\t\t\tlen = _._capacity;\r\n\t\t}\r\n\r\n\t\tvar tail = _._tail;\r\n\t\tarray[tail] = item;\r\n\t\t_._tail = (tail + 1)%len;\r\n\t\t_._size = size + 1;\r\n\t\t_._version++;\r\n\t}\r\n\r\n\tdequeue(throwIfEmpty:boolean = false):T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_._size==0)\r\n\t\t{\r\n\t\t\tif(throwIfEmpty)\r\n\t\t\t\tthrow new InvalidOperationException(\"Cannot dequeue an empty queue.\");\r\n\t\t\treturn void 0;\r\n\t\t}\r\n\r\n\t\tvar array = _._array, head = _._head;\r\n\r\n\t\tvar removed = _._array[head];\r\n\t\tarray[head] = null;\r\n\t\t_._head = (head + 1)%_._capacity;\r\n\r\n\t\t_._size--;\r\n\r\n\r\n\t\tif(_._size<_._capacity/2)\r\n\t\t{\r\n\t\t\t_.trimExcess(SHRINK_THRESHOLD);\r\n\t\t}\r\n\r\n\t\t_._version++;\r\n\t\treturn removed;\r\n\t}\r\n\r\n\ttryDequeue(out:(value:T)=>void):boolean\r\n\t{\r\n\t\tif(!this._size) return false;\r\n\t\tvar d = this.dequeue();\r\n\t\tif(out) out(d);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprivate _getElement(index:number):T\r\n\t{\r\n\t\tassertIntegerZeroOrGreater(index, \"index\");\r\n\r\n\t\tvar _ = this;\r\n\t\treturn _._array[(_._head + index)%_._capacity];\r\n\t}\r\n\r\n\tpeek():T\r\n\t{\r\n\t\tif(this._size==0)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot call peek on an empty queue.\");\r\n\r\n\t\treturn this._array[this._head];\r\n\t}\r\n\r\n\ttrimExcess(threshold?:number):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar size = _._size;\r\n\t\tif(size<Math.floor(_._capacity*0.9) && (isNaN(threshold) || threshold<size))\r\n\t\t\t_.setCapacity(size);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar index:number;\r\n\t\tvar version:number;\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tversion = _._version;\r\n\t\t\t\tindex = 0;\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\tif(version!=_._version)\r\n\t\t\t\t\tthrow new InvalidOperationException(\"Collection was changed during enumeration.\");\r\n\r\n\t\t\t\tif(index==_._size)\r\n\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\treturn yielder.yieldReturn(_._getElement(index++));\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction assertZeroOrGreater(value:number, property:string):void\r\n{\r\n\tif(value<0)\r\n\t\tthrow new ArgumentOutOfRangeException(property, value, \"Must be greater than zero\");\r\n\r\n}\r\n\r\nfunction assertIntegerZeroOrGreater(value:number, property:string):void\r\n{\r\n\tInteger.assert(value, property);\r\n\tassertZeroOrGreater(value, property);\r\n}\r\n","/*!\n * @author electricessence / https://github.com/electricessence/\n * Based Upon: http://referencesource.microsoft.com/#System/CompMod/system/collections/generic/queue.cs\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n'use strict';\nconst Values = require('../Compare');\nconst AU = require('./Array/Utility');\nconst Types_1 = require('../Types');\nconst Integer_1 = require('../Integer');\nconst EnumeratorBase_1 = require('./Enumeration/EnumeratorBase');\nconst forEach_1 = require('./Enumeration/forEach');\nconst NotImplementedException_1 = require('../Exceptions/NotImplementedException');\nconst InvalidOperationException_1 = require('../Exceptions/InvalidOperationException');\nconst ArgumentOutOfRangeException_1 = require('../Exceptions/ArgumentOutOfRangeException');\nconst MINIMUM_GROW = 4;\nconst SHRINK_THRESHOLD = 32;\nconst GROW_FACTOR_HALF = 100;\nconst DEFAULT_CAPACITY = MINIMUM_GROW;\nvar emptyArray = [];\nclass Queue {\n    constructor(source) {\n        var _ = this;\n        _._head = 0;\n        _._tail = 0;\n        _._size = 0;\n        _._version = 0;\n        if (!source)\n            _._array = emptyArray;\n        else {\n            if (Types_1.default.isNumber(source)) {\n                var capacity = source;\n                assertIntegerZeroOrGreater(capacity, \"capacity\");\n                _._array = capacity\n                    ? AU.initialize(capacity)\n                    : emptyArray;\n            }\n            else {\n                var se = source;\n                _._array = AU.initialize(Types_1.default.isArrayLike(se)\n                    ? se.length\n                    : DEFAULT_CAPACITY);\n                forEach_1.default(se, (e) => _.enqueue(e));\n                _._version = 0;\n            }\n        }\n        _._capacity = _._array.length;\n    }\n    get count() {\n        return this._size;\n    }\n    get isReadOnly() {\n        return false;\n    }\n    add(item) {\n        this.enqueue(item);\n    }\n    clear() {\n        var _ = this, array = _._array, head = _._head, tail = _._tail, size = _._size;\n        if (head < tail)\n            AU.clear(array, head, size);\n        else {\n            AU.clear(array, head, array.length - head);\n            AU.clear(array, 0, tail);\n        }\n        _._head = 0;\n        _._tail = 0;\n        _._size = 0;\n        _._version++;\n        _.trimExcess();\n        return size;\n    }\n    dump(max = Infinity) {\n        if (Types_1.default.isNumber(max, false) && max < 0)\n            throw new ArgumentOutOfRangeException_1.default('max', max, 'must be greater than or equal to 0.');\n        var _ = this, result = [];\n        if (isFinite(max)) {\n            Integer_1.default.assert(max, 'max');\n            while (max-- && _._size) {\n                result.push(_.dequeue());\n            }\n        }\n        else {\n            while (_._size) {\n                result.push(_.dequeue());\n            }\n        }\n        _.trimExcess();\n        return result;\n    }\n    contains(item) {\n        var _ = this;\n        var array = _._array, index = _._head, count = _._size, len = _._capacity;\n        while (count-- > 0) {\n            if (Values.areEqual(array[index], item))\n                return true;\n            index = (index + 1) % len;\n        }\n        return false;\n    }\n    copyTo(target, arrayIndex = 0) {\n        if (target == null)\n            throw new Error(\"ArgumentNullException: array cannot be null.\");\n        assertIntegerZeroOrGreater(arrayIndex, \"arrayIndex\");\n        var _ = this, size = _._size;\n        if (!size)\n            return;\n        var numToCopy = size, source = _._array, len = _._capacity, head = _._head, lh = len - head, firstPart = (lh < size)\n            ? lh\n            : size;\n        AU.copyTo(source, target, head, arrayIndex, firstPart);\n        numToCopy -= firstPart;\n        if (numToCopy > 0)\n            AU.copyTo(source, target, 0, arrayIndex + len - head, numToCopy);\n        return target;\n    }\n    toArray() {\n        var _ = this, size = _._size;\n        var arr = AU.initialize(size);\n        return size ? _.copyTo(arr) : arr;\n    }\n    remove(item) {\n        throw new NotImplementedException_1.default(\"ICollection\\<T\\>.remove is not implemented in Queue\\<T\\>\" +\n            \" since it would require destroying the underlying array to remove the item.\");\n    }\n    dispose() {\n        var _ = this;\n        _.clear();\n        if (_._array != emptyArray) {\n            _._array.length = _._capacity = 0;\n            _._array = emptyArray;\n        }\n        _._version = 0;\n    }\n    forEach(action) {\n        var _ = this, copy = _.toArray(), len = _._size;\n        for (let i = 0; i < len; i++) {\n            if (action(copy[i], i) === false)\n                break;\n        }\n    }\n    setCapacity(capacity) {\n        assertIntegerZeroOrGreater(capacity, \"capacity\");\n        var _ = this, array = _._array, len = _._capacity;\n        if (capacity == len)\n            return;\n        var head = _._head, tail = _._tail, size = _._size;\n        if (array != emptyArray && capacity > len && head < tail) {\n            array.length = _._capacity = capacity;\n            _._version++;\n            return;\n        }\n        var newArray = AU.initialize(capacity);\n        if (size > 0) {\n            if (head < tail) {\n                AU.copyTo(array, newArray, head, 0, size);\n            }\n            else {\n                AU.copyTo(array, newArray, head, 0, len - head);\n                AU.copyTo(array, newArray, 0, len - head, tail);\n            }\n        }\n        _._array = newArray;\n        _._capacity = capacity;\n        _._head = 0;\n        _._tail = (size == capacity) ? 0 : size;\n        _._version++;\n    }\n    enqueue(item) {\n        var _ = this, array = _._array, size = _._size, len = _._capacity;\n        if (size == len) {\n            var newCapacity = len * GROW_FACTOR_HALF;\n            if (newCapacity < len + MINIMUM_GROW)\n                newCapacity = len + MINIMUM_GROW;\n            _.setCapacity(newCapacity);\n            array = _._array;\n            len = _._capacity;\n        }\n        var tail = _._tail;\n        array[tail] = item;\n        _._tail = (tail + 1) % len;\n        _._size = size + 1;\n        _._version++;\n    }\n    dequeue(throwIfEmpty = false) {\n        var _ = this;\n        if (_._size == 0) {\n            if (throwIfEmpty)\n                throw new InvalidOperationException_1.default(\"Cannot dequeue an empty queue.\");\n            return void 0;\n        }\n        var array = _._array, head = _._head;\n        var removed = _._array[head];\n        array[head] = null;\n        _._head = (head + 1) % _._capacity;\n        _._size--;\n        if (_._size < _._capacity / 2) {\n            _.trimExcess(SHRINK_THRESHOLD);\n        }\n        _._version++;\n        return removed;\n    }\n    tryDequeue(out) {\n        if (!this._size)\n            return false;\n        var d = this.dequeue();\n        if (out)\n            out(d);\n        return true;\n    }\n    _getElement(index) {\n        assertIntegerZeroOrGreater(index, \"index\");\n        var _ = this;\n        return _._array[(_._head + index) % _._capacity];\n    }\n    peek() {\n        if (this._size == 0)\n            throw new InvalidOperationException_1.default(\"Cannot call peek on an empty queue.\");\n        return this._array[this._head];\n    }\n    trimExcess(threshold) {\n        var _ = this;\n        var size = _._size;\n        if (size < Math.floor(_._capacity * 0.9) && (isNaN(threshold) || threshold < size))\n            _.setCapacity(size);\n    }\n    getEnumerator() {\n        var _ = this;\n        var index;\n        var version;\n        return new EnumeratorBase_1.default(() => {\n            version = _._version;\n            index = 0;\n        }, (yielder) => {\n            if (version != _._version)\n                throw new InvalidOperationException_1.default(\"Collection was changed during enumeration.\");\n            if (index == _._size)\n                return yielder.yieldBreak();\n            return yielder.yieldReturn(_._getElement(index++));\n        });\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Queue;\nfunction assertZeroOrGreater(value, property) {\n    if (value < 0)\n        throw new ArgumentOutOfRangeException_1.default(property, value, \"Must be greater than zero\");\n}\nfunction assertIntegerZeroOrGreater(value, property) {\n    Integer_1.default.assert(value, property);\n    assertZeroOrGreater(value, property);\n}\n"]}