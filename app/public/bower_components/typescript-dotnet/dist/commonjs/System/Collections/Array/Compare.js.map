{"version":3,"sources":["System/Collections/Array/Compare.js","System/Collections/Array/Compare.ts"],"names":[],"mappings":"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","file":"System/Collections/Array/Compare.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Values = require('../../Compare');\nconst Types_1 = require('../../Types');\nfunction validateSize(a, b) {\n    if (a && b && a === b || !a && !b)\n        return true;\n    if (!a || !b)\n        return false;\n    var len = a.length;\n    if (len !== b.length)\n        return false;\n    if (len === 0)\n        return true;\n    return len;\n}\nfunction areAllEqual(arrays, strict, equalityComparer = Values.areEqual) {\n    if (!arrays)\n        throw new Error(\"ArgumentNullException: 'arrays' cannot be null.\");\n    if (arrays.length < 2)\n        throw new Error(\"Cannot compare a set of arrays less than 2.\");\n    var first = arrays[0];\n    for (let i = 0, l = arrays.length; i < l; ++i) {\n        if (!areEqual(first, arrays[i], strict, equalityComparer))\n            return false;\n    }\n    return true;\n}\nexports.areAllEqual = areAllEqual;\nfunction areEqual(a, b, strict, equalityComparer = Values.areEqual) {\n    var len = validateSize(a, b);\n    if (Types_1.default.isBoolean(len))\n        return len;\n    for (let i = 0; i < len; ++i) {\n        if (!equalityComparer(a[i], b[i], strict))\n            return false;\n    }\n    return true;\n}\nexports.areEqual = areEqual;\nfunction copyAndSort(a, comparer) {\n    if (!a)\n        return null;\n    if (Array.isArray(a))\n        return a.slice();\n    var len = a.length, b;\n    if (len > 65536)\n        b = new Array(len);\n    else {\n        b = [];\n        b.length = len;\n    }\n    for (let i = 0; i < len; i++)\n        b[i] = a[i];\n    b.sort(comparer);\n    return b;\n}\nfunction areEquivalent(a, b, comparer = Values.compare) {\n    var len = validateSize(a, b);\n    if (Types_1.default.isBoolean(len))\n        return len;\n    a = copyAndSort(a, comparer);\n    b = copyAndSort(b, comparer);\n    for (let i = 0; i < len; ++i) {\n        if (comparer(a[i], b[i]) !== 0)\n            return false;\n    }\n    return true;\n}\nexports.areEquivalent = areEquivalent;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"IArray.d.ts\"/>\r\n///<reference path=\"../../FunctionTypes.d.ts\"/>\r\n///<reference path=\"../../Primitive.d.ts\"/>\r\n///<reference path=\"../../IComparable.d.ts\"/>\r\nimport * as Values from '../../Compare';\r\nimport Type from '../../Types';\r\n\r\n/*  validateSize: Utility for quick validation/invalidation of array equality.\r\n\tWhy this way?  Why not pass a closure for the last return?\r\n\tReason: Performance and avoiding the creation of new functions/closures. */\r\nfunction validateSize(a:IArray<any>, b:IArray<any>):any\r\n{\r\n\t// Both valid and are same object, or both are null/undefined.\r\n\tif(a && b && a===b || !a && !b)\r\n\t\treturn true;\r\n\r\n\t// At this point, at least one has to be non-null.\r\n\tif(!a || !b)\r\n\t\treturn false;\r\n\r\n\tvar len = a.length;\r\n\tif(len!==b.length)\r\n\t\treturn false;\r\n\r\n\t// If both are arrays and have zero length, they are equal.\r\n\tif(len===0)\r\n\t\treturn true;\r\n\r\n\t// Return the length for downstream processing.\r\n\treturn len;\r\n}\r\n\r\nexport function areAllEqual(\r\n\tarrays:any[][],\r\n\tstrict?:boolean,\r\n\tequalityComparer:EqualityComparison<any> = Values.areEqual):boolean\r\n{\r\n\tif(!arrays)\r\n\t\tthrow new Error(\"ArgumentNullException: 'arrays' cannot be null.\");\r\n\tif(arrays.length<2)\r\n\t\tthrow new Error(\"Cannot compare a set of arrays less than 2.\");\r\n\tvar first = arrays[0];\r\n\tfor(let i = 0, l = arrays.length; i<l; ++i)\r\n\t{\r\n\t\tif(!areEqual(first, arrays[i], strict, equalityComparer))\r\n\t\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nexport function areEqual<T>(\r\n\ta:IArray<T>, b:IArray<T>,\r\n\tstrict?:boolean,\r\n\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n{\r\n\tvar len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\tfor(let i = 0; i<len; ++i)\r\n\t{\r\n\t\tif(!equalityComparer(a[i], b[i], strict))\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nfunction copyAndSort<T>(a:IArray<T>, comparer:Comparison<T>):T[]\r\n{\r\n\tif(!a) return null;\r\n\tif(Array.isArray(a)) return (<Array<T>>a).slice();\r\n\tvar len = a.length, b:T[];\r\n\tif(len>65536) b = new Array(len);\r\n\telse\r\n\t{\r\n\t\tb = [];\r\n\t\tb.length = len;\r\n\t}\r\n\tfor(let i = 0; i<len; i++) b[i] = a[i];\r\n\tb.sort(comparer);\r\n\treturn b;\r\n}\r\n\r\nexport function areEquivalent<T extends Primitive>(a:IArray<T>, b:IArray<T>):boolean;\r\nexport function areEquivalent<T>(a:IArray<IComparable<T>>, b:IArray<IComparable<T>>):boolean;\r\nexport function areEquivalent<T>(a:IArray<T>, b:IArray<T>, comparer:Comparison<T>):boolean;\r\nexport function areEquivalent<T>(\r\n\ta:IArray<T>, b:IArray<T>,\r\n\tcomparer:Comparison<T> = Values.compare):boolean\r\n{\r\n\tvar len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\t// There might be a better more performant way to do this, but for the moment, this\r\n\t// works quite well.\r\n\ta = copyAndSort(a, comparer);\r\n\tb = copyAndSort(b, comparer);\r\n\r\n\tfor(let i = 0; i<len; ++i)\r\n\t{\r\n\t\tif(comparer(a[i], b[i])!==0)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n"]}