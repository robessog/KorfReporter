{"version":3,"sources":["System/Collections/LinkedList.ts","System/Collections/LinkedList.js"],"names":[],"mappings":";;;;;AAQA;;;;;;AAEA,IAAY,SAAM,QAAM,YAAN,CAAN;AACZ,IAAY,eAAY,QAAM,8BAAN,CAAZ;AACZ,IAAY,aAAU,QAAM,0BAAN,CAAV;AACZ,IAAA,mBAAA,QAA2B,8BAA3B,CAAA;AACA,IAAA,mBAAA,QAA2B,kBAA3B,CAAA;AACA,IAAA,8BAAA,QAAsC,yCAAtC,CAAA;AACA,IAAA,0BAAA,QAAkC,qCAAlC,CAAA;;IAeA;AAGC,aAHD,YAGC,CACQ,KADR,EAEQ,QAFR,EAGQ,IAHR,EAG6B;8BAN9B,cAM8B;;AAFrB,aAAA,KAAA,GAAA,KAAA,CAEqB;AADrB,aAAA,QAAA,GAAA,QAAA,CACqB;AAArB,aAAA,IAAA,GAAA,IAAA,CAAqB;KAH7B;;iBAHD;;yCAYe;AAEb,gBAAG,KAAK,IAAL,IAAa,KAAK,QAAL,EACf,MAAM,IAAI,4BAAA,OAAA,CACT,uCADK,CAAN,CADD;;;;WAdF;;;AAqBA,SAAA,cAAA,CAA2B,IAA3B,EAAiD,IAAjD,EAAmE;AAElE,QAAG,CAAC,IAAD,EACF,OAAO,IAAP,CADD;AAGA,QAAI,WAA8B,KAAK,QAAL,CALgC;AAMlE,QAAG,CAAC,QAAD,EACF,KAAK,QAAL,GAAgB,WAAW,IAAI,cAAJ,CAAsB,IAAtB,EAA4B,IAA5B,CAAX,CADjB;AAGA,WAAO,QAAP,CATkE;CAAnE;AAYA,SAAA,WAAA,CAAwB,IAAxB,EAAiD,IAAjD,EAAmE;AAElE,QAAG,CAAC,IAAD,EACF,MAAM,IAAI,wBAAA,OAAA,CACT,iBADK,CAAN,CADD;AAIA,QAAG,KAAK,IAAL,IAAW,IAAX,EACF,MAAM,IAAI,4BAAA,OAAA,CACT,6CADK,CAAN,CADD;AAIA,QAAI,IAA0B,KAAM,aAAN,CAVoC;AAWlE,QAAG,CAAC,CAAD,EACF,MAAM,IAAI,4BAAA,OAAA,CACT,6BADK,CAAN,CADD;AAIA,WAAO,CAAP,CAfkE;CAAnE;;IAkBA;AASC,aATD,UASC,CAAY,MAAZ,EAAsB;8BATvB,YASuB;;AAErB,YAAI,IAAI,IAAJ;YAAU,IAAI,CAAJ,CAFO;AAGrB,YAAI,IAAI,WAAW,IAAX,CAAmB,MAAnB,CAAJ,CAHiB;AAKrB,YAAI,OAAO,EAAE,aAAF,GAAkB,IAAI,iBAAA,OAAA,EAAtB,CALU;AAOrB,eAAM,EAAE,QAAF,EAAN,EACA;AACC,iBAAK,OAAL,CAAc,IAAI,YAAJ,CAAoB,EAAE,OAAF,CAAlC,EADD;AAEC,cAAE,CAAF,CAFD;SADA;AAMA,UAAE,MAAF,GAAW,CAAX,CAbqB;KAAtB;;iBATD;;gCA4BE,QACuB;gBAAvB,gEAAkB,qBAAK;;AAEvB,gBAAG,OAAH,EACA;AACC,oBAAI,QAAQ,KAAK,OAAL,EAAR,CADL;AAEC,6BAAa,OAAb,CAAqB,KAArB,EAA4B,MAA5B,EAFD;AAGC,sBAAM,MAAN,GAAe,CAAf,CAHD;aADA,MAOA;AACC,qBAAK,aAAL,CAAmB,OAAnB,CAA2B,UAAC,IAAD,EAAO,CAAP;2BAAW,OAAO,KAAK,KAAL,EAAY,CAAnB;iBAAX,CAA3B,CADD;aAPA;;;;wCAeY;AAEZ,gBAAI,IAAI,IAAJ;gBACA,OADJ;gBAEI,IAFJ,CAFY;AAMZ,mBAAO,IAAI,iBAAA,OAAA,CACV,YAAA;AAGC,0BAAU,IAAV,CAHD;AAIC,uBAAO,EAAE,aAAF,CAAgB,KAAhB,CAJR;aAAA,EAMA,UAAC,OAAD,EAAQ;AAGP,oBAAG,IAAH,EACA;AACC,8BAAU,IAAV,CADD;AAEC,2BAAO,WAAW,QAAQ,IAAR,CAFnB;AAGC,2BAAO,QAAQ,WAAR,CAAoB,QAAQ,KAAR,CAA3B,CAHD;iBADA;AAOA,uBAAO,QAAQ,UAAR,EAAP,CAVO;aAAR,CAPD,CANY;;;;mCA8BM,OAAO;AAEzB,gBAAI,SAAS,OAAO,QAAP;gBACT,OAAS,KAAK,aAAL,CAAmB,KAAnB,CAHY;AAIzB,mBAAM,IAAN,EACA;AACC,oBAAG,OAAO,KAAP,EAAc,KAAK,KAAL,CAAjB,EACC,OAAO,IAAP,CADD;AAEA,uBAAO,KAAK,IAAL,CAHR;aADA;AAMA,mBAAO,IAAP,CAVyB;;;;kCAaR,OAAO;AAExB,gBAAI,SAAS,OAAO,QAAP;gBACT,OAAS,KAAK,aAAL,CAAmB,IAAnB,CAHW;AAIxB,mBAAM,IAAN,EACA;AACC,oBAAG,OAAO,KAAP,EAAc,KAAK,KAAL,CAAjB,EACC,OAAO,IAAP,CADD;AAEA,uBAAO,KAAK,QAAL,CAHR;aADA;AAMA,mBAAO,IAAP,CAVwB;;;;4BAyBrB,OAAO;AAEV,iBAAK,aAAL,CAAmB,OAAnB,CAA2B,IAAI,YAAJ,CAAiB,KAAjB,CAA3B,EAFU;AAGV,iBAAK,MAAL,GAHU;;;;gCAON;AAEJ,iBAAK,MAAL,GAAc,CAAd,CAFI;AAGJ,mBAAO,KAAK,aAAL,CAAmB,KAAnB,EAAP,CAHI;;;;iCAOI,OAAO;AAEf,gBAAI,QAAgB,KAAhB;gBAAuB,SAAS,OAAO,QAAP,CAFrB;AAGf,iBAAK,OAAL,CAAa;uBAAK,EAAE,QAAQ,OAAO,KAAP,EAAc,CAAd,CAAR,CAAF;aAAL,CAAb,CAHe;AAIf,mBAAO,KAAP,CAJe;;;;+BAOT,OAA2B;gBAAhB,8DAAe,iBAAC;;AAEjC,gBAAG,CAAC,KAAD,EAAQ,MAAM,IAAI,wBAAA,OAAA,CAAsB,OAA1B,CAAN,CAAX;AAEA,gBAAG,KAAK,aAAL,CAAmB,KAAnB,EACH;AACC,oBAAI,YAAY,QAAQ,KAAK,MAAL,CADzB;AAEC,oBAAG,MAAM,MAAN,GAAa,SAAb,EAAwB,MAAM,MAAN,GAAe,SAAf,CAA3B;AACA,qBAAK,OAAL,CACC,UAAC,KAAD,EAAQ,CAAR,EAAS;AAER,0BAAM,QAAQ,CAAR,CAAN,GAAmB,KAAnB,CAFQ;iBAAT,CADD,CAHD;aADA;AAYA,mBAAO,KAAP,CAhBiC;;;;kCAmB3B;AAEN,gBAAI,QAAQ,aAAa,UAAb,CAA2B,KAAK,MAAL,CAAnC,CAFE;AAGN,mBAAO,KAAK,MAAL,CAAY,KAAZ,CAAP,CAHM;;;;mCAMI,OAAO;AAEjB,mBAAO,KAAK,MAAL,CAAY,KAAZ,EAAmB,CAAnB,MAAwB,CAAxB,CAFU;;;;+BAKX,OAA8B;gBAArB,4DAAa,wBAAQ;;AAEpC,gBAAI,SAAS,OAAO,QAAP,CAFuB;AAGpC,gBAAI,IAAI,IAAJ;gBAAU,OAAO,EAAE,aAAF;gBAAiB,eAAsB,CAAtB,CAHF;AAKpC,iBAAK,OAAL,CAAa,gBAAI;AAEhB,oBAAG,OAAO,KAAP,EAAc,KAAK,KAAL,CAAd,IAA6B,KAAK,UAAL,CAAgB,IAAhB,CAA7B,EACH;AACC,sBAAE,EAAE,MAAF,CADH;AAEC,sBAAE,YAAF,CAFD;iBADA;AAKA,uBAAO,eAAa,GAAb,CAPS;aAAJ,CAAb,CALoC;AAepC,mBAAO,YAAP,CAfoC;;;;mCAmC1B,OAAY;AAEtB,mBAAO,KAAK,aAAL,CAAmB,SAAnB,CAA6B,KAA7B,EAAoC,KAApC,CAFe;;;;kCAKb,OAAY;AAErB,mBAAO,eAAe,KAAK,aAAL,CAAmB,SAAnB,CAA6B,KAA7B,CAAf,EAAoD,IAApD,CAAP,CAFqB;;;;6BAKjB,OAAO;AAEX,mBAAO,eAAe,KAAK,UAAL,CAAgB,KAAhB,CAAf,EAAuC,IAAvC,CAAP,CAFW;;;;iCAKH,OAAO;AAEf,mBAAO,eAAe,KAAK,SAAL,CAAe,KAAf,CAAf,EAAsC,IAAtC,CAAP,CAFe;;;;iCAKP,OAAO;AAEf,iBAAK,aAAL,CAAmB,aAAnB,CAAiC,IAAI,YAAJ,CAAiB,KAAjB,CAAjC,EAFe;AAGf,cAAE,KAAK,MAAL,CAHa;;;;gCAMR,OAAO;AAEd,iBAAK,GAAL,CAAS,KAAT,EAFc;;;;sCAKJ;AAEV,gBAAI,IAAI,IAAJ;gBAAU,QAAQ,EAAE,aAAF,CAAgB,KAAhB,CAFZ;AAGV,gBAAG,SAAS,EAAE,aAAF,CAAgB,UAAhB,CAA2B,KAA3B,CAAT,EAA4C;AAC9C,kBAAE,MAAF,GAD8C;aAA/C;;;;qCAKS;AAET,gBAAI,IAAI,IAAJ;gBAAU,OAAO,EAAE,aAAF,CAAgB,IAAhB,CAFZ;AAGT,gBAAG,QAAQ,EAAE,aAAF,CAAgB,UAAhB,CAA2B,IAA3B,CAAR,EAA0C;AAC5C,kBAAE,EAAE,MAAF,CAD0C;aAA7C;;;;mCAMU,MAAuB;AAEjC,gBAAI,IAAI,IAAJ;gBACA,UAAU,EAAE,aAAF,CAAgB,UAAhB,CAA2B,YAAY,IAAZ,EAAkB,CAAlB,CAA3B,CAAV,CAH6B;AAKjC,gBAAG,OAAH,EAAY,EAAE,EAAE,MAAF,CAAd;AAEA,mBAAO,OAAP,CAPiC;;;;kCAUxB,QAA2B,OAAO;AAE3C,iBAAK,aAAL,CAAmB,aAAnB,CACC,IAAI,YAAJ,CAAiB,KAAjB,CADD,EAEC,YAAY,MAAZ,EAAoB,IAApB,CAFD,EAF2C;AAM3C,cAAE,KAAK,MAAL,CANyC;;;;iCAUnC,OAA0B,OAAO;AAEzC,iBAAK,aAAL,CAAmB,YAAnB,CACC,IAAI,YAAJ,CAAiB,KAAjB,CADD,EAEC,YAAY,KAAZ,EAAmB,IAAnB,CAFD,EAFyC;AAMzC,cAAE,KAAK,MAAL,CANuC;;;;sCAS5B,MAAyB,QAAyB;AAE/D,iBAAK,aAAL,CAAmB,aAAnB,CACC,YAAY,MAAZ,EAAoB,IAApB,CADD,EAEC,YAAY,IAAZ,EAAkB,IAAlB,CAFD,EAF+D;AAM/D,cAAE,KAAK,MAAL,CAN6D;;;;qCASnD,MAAyB,OAAwB;AAE7D,iBAAK,aAAL,CAAmB,YAAnB,CACC,YAAY,KAAZ,EAAmB,IAAnB,CADD,EAEC,YAAY,IAAZ,EAAkB,IAAlB,CAFD,EAF6D;AAM7D,cAAE,KAAK,MAAL,CAN2D;;;;4BAvLrD;AAER,mBAAO,KAAK,MAAL,CAFC;;;;4BAMK;AAEb,mBAAO,KAAP,CAFa;;;;4BA8EL;AAER,mBAAO,eAAe,KAAK,aAAL,CAAmB,KAAnB,EAA0B,IAAzC,CAAP,CAFQ;;;;4BAKD;AAEP,mBAAO,eAAe,KAAK,aAAL,CAAmB,IAAnB,EAAyB,IAAxC,CAAP,CAFO;;;;WAhMT;;;AAAA,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;AC6HA,QAAQ,OAAR,GAAkB,UAAlB;;ID8KA;AAEC,aAFD,cAEC,CACS,KADT,EAES,aAFT,EAEsC;8BAJvC,gBAIuC;;AAD7B,aAAA,KAAA,GAAA,KAAA,CAC6B;AAA7B,aAAA,aAAA,GAAA,aAAA,CAA6B;KAFtC;;iBAFD;;kCAiCW,OAAO;AAEhB,iBAAK,KAAL,CAAW,SAAX,CAAqB,IAArB,EAA2B,KAA3B,EAFgB;;;;iCAKR,OAAO;AAEf,iBAAK,KAAL,CAAW,QAAX,CAAoB,IAApB,EAA0B,KAA1B,EAFe;;;;sCAKF,QAAyB;AAEtC,iBAAK,KAAL,CAAW,aAAX,CAAyB,IAAzB,EAA+B,MAA/B,EAFsC;;;;qCAK1B,OAAwB;AAEpC,iBAAK,KAAL,CAAW,YAAX,CAAwB,IAAxB,EAA8B,KAA9B,EAFoC;;;;iCAK/B;AAEL,iBAAK,KAAL,CAAW,UAAX,CAAsB,IAAtB,EAFK;;;;4BA7CE;AAEP,mBAAO,KAAK,KAAL,CAFA;;;;4BAKI;AAEX,mBAAO,eAAe,KAAK,aAAL,CAAmB,QAAnB,EAA6B,KAAK,KAAL,CAAnD,CAFW;;;;4BAKJ;AAEP,mBAAO,eAAe,KAAK,aAAL,CAAmB,IAAnB,EAAyB,KAAK,KAAL,CAA/C,CAFO;;;;4BAKC;AAER,mBAAO,KAAK,aAAL,CAAmB,KAAnB,CAFC;;0BAKC,GAAG;AAEZ,iBAAK,aAAL,CAAmB,KAAnB,GAA2B,CAA3B,CAFY;;;;WA5Bd","file":"System/Collections/LinkedList.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"ILinkedListNode.d.ts\"/>\r\n///<reference path=\"ILinkedList.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport * as Values from \"../Compare\";\r\nimport * as ArrayUtility from \"../Collections/Array/Utility\";\r\nimport * as Enumerator from \"./Enumeration/Enumerator\";\r\nimport EnumeratorBase from \"./Enumeration/EnumeratorBase\";\r\nimport LinkedNodeList from \"./LinkedNodeList\";\r\nimport InvalidOperationException from \"../Exceptions/InvalidOperationException\";\r\nimport ArgumentNullException from \"../Exceptions/ArgumentNullException\";\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n/*\r\n * An internal node is used to manage the order without exposing underlying link chain to the consumer.\r\n */\r\nclass InternalNode<T>\r\nimplements ILinkedNode<InternalNode<T>>, INodeWithValue<T>\r\n{\r\n\tconstructor(\r\n\t\tpublic value?:T,\r\n\t\tpublic previous?:InternalNode<T>,\r\n\t\tpublic next?:InternalNode<T>)\r\n\t{\r\n\t}\r\n\r\n\texternal:ILinkedListNode<T>;\r\n\r\n\tassertDetached():void\r\n\t{\r\n\t\tif(this.next || this.previous)\r\n\t\t\tthrow new InvalidOperationException(\r\n\t\t\t\t\"Adding a node that is already placed.\");\r\n\t}\r\n\r\n}\r\n\r\nfunction ensureExternal<T>(node:InternalNode<T>, list:LinkedList<T>):ILinkedListNode<T>\r\n{\r\n\tif(!node)\r\n\t\treturn null;\r\n\r\n\tvar external:ILinkedListNode<T> = node.external;\r\n\tif(!external)\r\n\t\tnode.external = external = new LinkedListNode<T>(list, node);\r\n\r\n\treturn external;\r\n}\r\n\r\nfunction getInternal<T>(node:ILinkedListNode<T>, list:LinkedList<T>):InternalNode<T>\r\n{\r\n\tif(!node)\r\n\t\tthrow new ArgumentNullException(\r\n\t\t\t\"Cannot be null.\");\r\n\r\n\tif(node.list!=list)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node does not belong to this list.\");\r\n\r\n\tvar n:InternalNode<T> = (<any>node)._nodeInternal;\r\n\tif(!n)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node is not valid.\");\r\n\r\n\treturn n;\r\n}\r\n\r\nexport default\r\nclass LinkedList<T>\r\nimplements ILinkedList<T>\r\n{\r\n\tprivate _listInternal:LinkedNodeList<InternalNode<T>>;\r\n\tprivate _count:number;\r\n\r\n\tconstructor(source?:IEnumerable<T>);\r\n\tconstructor(source?:IArray<T>);\r\n\tconstructor(source:any)\r\n\t{\r\n\t\tvar _ = this, c = 0;\r\n\t\tvar e = Enumerator.from<T>(source);\r\n\r\n\t\tvar list = _._listInternal = new LinkedNodeList<InternalNode<T>>();\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tlist.addNode( new InternalNode<T>(e.current) );\r\n\t\t\t++c;\r\n\t\t}\r\n\r\n\t\t_._count = c;\r\n\t}\r\n\r\n\r\n\t// #region IEnumerateEach<T>\r\n\tforEach(\r\n\t\taction:Predicate<T> | Action<T>,\r\n\t\tuseCopy:boolean = false):void\r\n\t{\r\n\t\tif(useCopy)\r\n\t\t{\r\n\t\t\tvar array = this.toArray();\r\n\t\t\tArrayUtility.forEach(array, action);\r\n\t\t\tarray.length = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis._listInternal.forEach((node, i)=>action(node.value, i));\r\n\t\t}\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region IEnumerable<T>\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\tvar _ = this,\r\n\t\t    current:InternalNode<T>,\r\n\t\t    next:InternalNode<T>;\r\n\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t// Initialize anchor...\r\n\t\t\t\tcurrent = null;\r\n\t\t\t\tnext = _._listInternal.first;\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\r\n\t\t\t\tif(next)\r\n\t\t\t\t{\r\n\t\t\t\t\tcurrent = next;\r\n\t\t\t\t\tnext = current && current.next;\r\n\t\t\t\t\treturn yielder.yieldReturn(current.value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tprivate _findFirst(entry:T):InternalNode<T>\r\n\t{\r\n\t\tvar equals = Values.areEqual,\r\n\t\t    next   = this._listInternal.first;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\tif(equals(entry, next.value))\r\n\t\t\t\treturn next;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate _findLast(entry:T):InternalNode<T>\r\n\t{\r\n\t\tvar equals = Values.areEqual,\r\n\t\t    prev   = this._listInternal.last;\r\n\t\twhile(prev)\r\n\t\t{\r\n\t\t\tif(equals(entry, prev.value))\r\n\t\t\t\treturn prev;\r\n\t\t\tprev = prev.previous;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// #region ICollection<T>\r\n\tget count():number\r\n\t{\r\n\t\treturn this._count;\r\n\t}\r\n\r\n\t//noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols\r\n\tget isReadOnly():boolean\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tadd(entry:T):void\r\n\t{\r\n\t\tthis._listInternal.addNode(new InternalNode(entry));\r\n\t\tthis._count++;\r\n\t}\r\n\r\n\r\n\tclear():number\r\n\t{\r\n\t\tthis._count = 0;\r\n\t\treturn this._listInternal.clear();\r\n\t}\r\n\r\n\r\n\tcontains(entry:T):boolean\r\n\t{\r\n\t\tvar found:boolean = false, equals = Values.areEqual;\r\n\t\tthis.forEach(e => !(found = equals(entry, e)));\r\n\t\treturn found;\r\n\t}\r\n\r\n\tcopyTo(array:T[], index:number = 0):T[]\r\n\t{\r\n\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\tif(this._listInternal.first)\r\n\t\t{\r\n\t\t\tvar minLength = index + this._count;\r\n\t\t\tif(array.length<minLength) array.length = minLength; // Preset the length if need be.\r\n\t\t\tthis.forEach(\r\n\t\t\t\t(entry, i) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tarray[index + i] = entry;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tvar array = ArrayUtility.initialize<T>(this._count);\r\n\t\treturn this.copyTo(array);\r\n\t}\r\n\r\n\tremoveOnce(entry:T):boolean\r\n\t{\r\n\t\treturn this.remove(entry, 1)!==0;\r\n\t}\r\n\r\n\tremove(entry:T, max:number = Infinity):number\r\n\t{\r\n\t\tvar equals = Values.areEqual;\r\n\t\tvar _ = this, list = _._listInternal, removedCount:number = 0;\r\n\r\n\t\tlist.forEach(node=>\r\n\t\t{\r\n\t\t\tif(equals(entry, node.value) && list.removeNode(node))\r\n\t\t\t{\r\n\t\t\t\t--_._count;\r\n\t\t\t\t++removedCount;\r\n\t\t\t}\r\n\t\t\treturn removedCount<max;\r\n\t\t});\r\n\r\n\t\treturn removedCount;\r\n\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\tget first():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._listInternal.first, this);\r\n\t}\r\n\r\n\tget last():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._listInternal.last, this);\r\n\t}\r\n\r\n\t// get methods are available for convenience but is an n*index operation.\r\n\r\n\r\n\tgetValueAt(index:number):T\r\n\t{\r\n\t\treturn this._listInternal.getNodeAt(index).value;\r\n\t}\r\n\r\n\tgetNodeAt(index:number):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._listInternal.getNodeAt(index), this);\r\n\t}\r\n\r\n\tfind(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findFirst(entry), this);\r\n\t}\r\n\r\n\tfindLast(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findLast(entry), this);\r\n\t}\r\n\r\n\taddFirst(entry:T):void\r\n\t{\r\n\t\tthis._listInternal.addNodeBefore(new InternalNode(entry));\r\n\t\t++this._count;\r\n\t}\r\n\r\n\taddLast(entry:T):void\r\n\t{\r\n\t\tthis.add(entry);\r\n\t}\r\n\r\n\tremoveFirst():void\r\n\t{\r\n\t\tvar _ = this, first = _._listInternal.first;\r\n\t\tif(first && _._listInternal.removeNode(first)) {\r\n\t\t\t_._count--;\r\n\t\t}\r\n\t}\r\n\r\n\tremoveLast():void\r\n\t{\r\n\t\tvar _ = this, last = _._listInternal.last;\r\n\t\tif(last && _._listInternal.removeNode(last)) {\r\n\t\t\t--_._count;\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns true if successful and false if not found (already removed).\r\n\tremoveNode(node:ILinkedListNode<T>):boolean\r\n\t{\r\n\t\tvar _ = this,\r\n\t\t    removed = _._listInternal.removeNode(getInternal(node, _));\r\n\r\n\t\tif(removed) --_._count;\r\n\r\n\t\treturn removed;\r\n\t}\r\n\r\n\taddBefore(before:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tthis._listInternal.addNodeBefore(\r\n\t\t\tnew InternalNode(entry),\r\n\t\t\tgetInternal(before, this)\r\n\t\t);\r\n\t\t++this._count;\r\n\t}\r\n\r\n\r\n\taddAfter(after:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tthis._listInternal.addNodeAfter(\r\n\t\t\tnew InternalNode(entry),\r\n\t\t\tgetInternal(after, this)\r\n\t\t);\r\n\t\t++this._count;\r\n\t}\r\n\r\n\taddNodeBefore(node:ILinkedListNode<T>, before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._listInternal.addNodeBefore(\r\n\t\t\tgetInternal(before, this),\r\n\t\t\tgetInternal(node, this)\r\n\t\t);\r\n\t\t++this._count;\r\n\t}\r\n\r\n\taddNodeAfter(node:ILinkedListNode<T>, after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._listInternal.addNodeAfter(\r\n\t\t\tgetInternal(after, this),\r\n\t\t\tgetInternal(node, this)\r\n\t\t);\r\n\t\t++this._count;\r\n\t}\r\n\r\n\r\n}\r\n\r\n// Use an internal node class to prevent mucking up the LinkedList.\r\nclass LinkedListNode<T> implements ILinkedListNode<T>\r\n{\r\n\tconstructor(\r\n\t\tprivate _list:LinkedList<T>,\r\n\t\tprivate _nodeInternal:InternalNode<T>)\r\n\t{\r\n\t}\r\n\r\n\tget list():LinkedList<T>\r\n\t{\r\n\t\treturn this._list;\r\n\t}\r\n\r\n\tget previous():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._nodeInternal.previous, this._list);\r\n\t}\r\n\r\n\tget next():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._nodeInternal.next, this._list);\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this._nodeInternal.value;\r\n\t}\r\n\r\n\tset value(v:T)\r\n\t{\r\n\t\tthis._nodeInternal.value = v;\r\n\t}\r\n\r\n\taddBefore(entry:T):void\r\n\t{\r\n\t\tthis._list.addBefore(this, entry);\r\n\t}\r\n\r\n\taddAfter(entry:T):void\r\n\t{\r\n\t\tthis._list.addAfter(this, entry);\r\n\t}\r\n\r\n\taddNodeBefore(before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeBefore(this, before);\r\n\t}\r\n\r\n\taddNodeAfter(after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeAfter(this, after);\r\n\t}\r\n\r\n\tremove():void\r\n\t{\r\n\t\tthis._list.removeNode(this);\r\n\t}\r\n\r\n}\r\n\r\n","/*!\n * @author electricessence / https://github.com/electricessence/\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n'use strict';\nconst Values = require(\"../Compare\");\nconst ArrayUtility = require(\"../Collections/Array/Utility\");\nconst Enumerator = require(\"./Enumeration/Enumerator\");\nconst EnumeratorBase_1 = require(\"./Enumeration/EnumeratorBase\");\nconst LinkedNodeList_1 = require(\"./LinkedNodeList\");\nconst InvalidOperationException_1 = require(\"../Exceptions/InvalidOperationException\");\nconst ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\nclass InternalNode {\n    constructor(value, previous, next) {\n        this.value = value;\n        this.previous = previous;\n        this.next = next;\n    }\n    assertDetached() {\n        if (this.next || this.previous)\n            throw new InvalidOperationException_1.default(\"Adding a node that is already placed.\");\n    }\n}\nfunction ensureExternal(node, list) {\n    if (!node)\n        return null;\n    var external = node.external;\n    if (!external)\n        node.external = external = new LinkedListNode(list, node);\n    return external;\n}\nfunction getInternal(node, list) {\n    if (!node)\n        throw new ArgumentNullException_1.default(\"Cannot be null.\");\n    if (node.list != list)\n        throw new InvalidOperationException_1.default(\"Provided node does not belong to this list.\");\n    var n = node._nodeInternal;\n    if (!n)\n        throw new InvalidOperationException_1.default(\"Provided node is not valid.\");\n    return n;\n}\nclass LinkedList {\n    constructor(source) {\n        var _ = this, c = 0;\n        var e = Enumerator.from(source);\n        var list = _._listInternal = new LinkedNodeList_1.default();\n        while (e.moveNext()) {\n            list.addNode(new InternalNode(e.current));\n            ++c;\n        }\n        _._count = c;\n    }\n    forEach(action, useCopy = false) {\n        if (useCopy) {\n            var array = this.toArray();\n            ArrayUtility.forEach(array, action);\n            array.length = 0;\n        }\n        else {\n            this._listInternal.forEach((node, i) => action(node.value, i));\n        }\n    }\n    getEnumerator() {\n        var _ = this, current, next;\n        return new EnumeratorBase_1.default(() => {\n            current = null;\n            next = _._listInternal.first;\n        }, (yielder) => {\n            if (next) {\n                current = next;\n                next = current && current.next;\n                return yielder.yieldReturn(current.value);\n            }\n            return yielder.yieldBreak();\n        });\n    }\n    _findFirst(entry) {\n        var equals = Values.areEqual, next = this._listInternal.first;\n        while (next) {\n            if (equals(entry, next.value))\n                return next;\n            next = next.next;\n        }\n        return null;\n    }\n    _findLast(entry) {\n        var equals = Values.areEqual, prev = this._listInternal.last;\n        while (prev) {\n            if (equals(entry, prev.value))\n                return prev;\n            prev = prev.previous;\n        }\n        return null;\n    }\n    get count() {\n        return this._count;\n    }\n    get isReadOnly() {\n        return false;\n    }\n    add(entry) {\n        this._listInternal.addNode(new InternalNode(entry));\n        this._count++;\n    }\n    clear() {\n        this._count = 0;\n        return this._listInternal.clear();\n    }\n    contains(entry) {\n        var found = false, equals = Values.areEqual;\n        this.forEach(e => !(found = equals(entry, e)));\n        return found;\n    }\n    copyTo(array, index = 0) {\n        if (!array)\n            throw new ArgumentNullException_1.default('array');\n        if (this._listInternal.first) {\n            var minLength = index + this._count;\n            if (array.length < minLength)\n                array.length = minLength;\n            this.forEach((entry, i) => {\n                array[index + i] = entry;\n            });\n        }\n        return array;\n    }\n    toArray() {\n        var array = ArrayUtility.initialize(this._count);\n        return this.copyTo(array);\n    }\n    removeOnce(entry) {\n        return this.remove(entry, 1) !== 0;\n    }\n    remove(entry, max = Infinity) {\n        var equals = Values.areEqual;\n        var _ = this, list = _._listInternal, removedCount = 0;\n        list.forEach(node => {\n            if (equals(entry, node.value) && list.removeNode(node)) {\n                --_._count;\n                ++removedCount;\n            }\n            return removedCount < max;\n        });\n        return removedCount;\n    }\n    get first() {\n        return ensureExternal(this._listInternal.first, this);\n    }\n    get last() {\n        return ensureExternal(this._listInternal.last, this);\n    }\n    getValueAt(index) {\n        return this._listInternal.getNodeAt(index).value;\n    }\n    getNodeAt(index) {\n        return ensureExternal(this._listInternal.getNodeAt(index), this);\n    }\n    find(entry) {\n        return ensureExternal(this._findFirst(entry), this);\n    }\n    findLast(entry) {\n        return ensureExternal(this._findLast(entry), this);\n    }\n    addFirst(entry) {\n        this._listInternal.addNodeBefore(new InternalNode(entry));\n        ++this._count;\n    }\n    addLast(entry) {\n        this.add(entry);\n    }\n    removeFirst() {\n        var _ = this, first = _._listInternal.first;\n        if (first && _._listInternal.removeNode(first)) {\n            _._count--;\n        }\n    }\n    removeLast() {\n        var _ = this, last = _._listInternal.last;\n        if (last && _._listInternal.removeNode(last)) {\n            --_._count;\n        }\n    }\n    removeNode(node) {\n        var _ = this, removed = _._listInternal.removeNode(getInternal(node, _));\n        if (removed)\n            --_._count;\n        return removed;\n    }\n    addBefore(before, entry) {\n        this._listInternal.addNodeBefore(new InternalNode(entry), getInternal(before, this));\n        ++this._count;\n    }\n    addAfter(after, entry) {\n        this._listInternal.addNodeAfter(new InternalNode(entry), getInternal(after, this));\n        ++this._count;\n    }\n    addNodeBefore(node, before) {\n        this._listInternal.addNodeBefore(getInternal(before, this), getInternal(node, this));\n        ++this._count;\n    }\n    addNodeAfter(node, after) {\n        this._listInternal.addNodeAfter(getInternal(after, this), getInternal(node, this));\n        ++this._count;\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LinkedList;\nclass LinkedListNode {\n    constructor(_list, _nodeInternal) {\n        this._list = _list;\n        this._nodeInternal = _nodeInternal;\n    }\n    get list() {\n        return this._list;\n    }\n    get previous() {\n        return ensureExternal(this._nodeInternal.previous, this._list);\n    }\n    get next() {\n        return ensureExternal(this._nodeInternal.next, this._list);\n    }\n    get value() {\n        return this._nodeInternal.value;\n    }\n    set value(v) {\n        this._nodeInternal.value = v;\n    }\n    addBefore(entry) {\n        this._list.addBefore(this, entry);\n    }\n    addAfter(entry) {\n        this._list.addAfter(this, entry);\n    }\n    addNodeBefore(before) {\n        this._list.addNodeBefore(this, before);\n    }\n    addNodeAfter(after) {\n        this._list.addNodeAfter(this, after);\n    }\n    remove() {\n        this._list.removeNode(this);\n    }\n}\n"]}