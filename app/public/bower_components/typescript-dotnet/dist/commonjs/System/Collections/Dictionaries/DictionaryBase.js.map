{"version":3,"sources":["System/Collections/Dictionaries/DictionaryBase.ts","System/Collections/Dictionaries/DictionaryBase.js"],"names":[],"mappings":"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","file":"System/Collections/Dictionaries/DictionaryBase.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"IDictionary.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport {areEqual} from '../../Compare';\r\nimport EnumeratorBase from '../Enumeration/EnumeratorBase';\r\nimport ArgumentException from '../../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../../Exceptions/ArgumentNullException';\r\nimport InvalidOperationException from '../../Exceptions/InvalidOperationException';\r\nimport extractKeyValue from '../../KeyValueExtract';\r\nimport {forEach} from '../Enumeration/Enumerator';\r\n\r\nconst VOID0:any = void(0);\r\n\r\n// Design Note: Should DictionaryAbstractBase be IDisposable?\r\nabstract class DictionaryBase<TKey, TValue>\r\nimplements IDictionary<TKey, TValue>\r\n{\r\n\t// This allows for batch updates in order to improve the efficiency of responsive systems.\r\n\tprivate _updateRecursion:number;\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tthis._updateRecursion = 0;\r\n\t}\r\n\r\n\tget isUpdating():boolean { return this._updateRecursion!=0; }\r\n\r\n\t// Could implement an event dispatcher pattern here easily...\r\n\tonValueChanged:(key:TKey, value:TValue, old:TValue) => void;\r\n\r\n\tprotected _onValueUpdate(key:TKey, value:TValue, old:TValue):void\r\n\t{\r\n\t\tif(!areEqual(value, old, true))\r\n\t\t{\r\n\r\n\t\t\tvar _ = this;\r\n\t\t\tif(_.onValueChanged)\r\n\t\t\t\t_.onValueChanged(key, value, old);\r\n\r\n\t\t\t// If the update recursion is zero, then we are finished with updates.\r\n\t\t\tif(_._updateRecursion==0)\r\n\t\t\t\t_._onUpdated();\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t// Listening to every value update can get noisy.  Here we allow for batch update signaling.\r\n\t// The consumer of this class can also wire up their own event system.\r\n\tonUpdated:() => void;\r\n\r\n\tprivate _onUpdated():void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_.onUpdated)\r\n\t\t\t_.onUpdated();\r\n\t}\r\n\r\n\t// Takes a closure that if returning true will propagate an update signal.\r\n\thandleUpdate(closure?:() => boolean):boolean\r\n\t{\r\n\t\tvar _ = this, result:boolean;\r\n\t\tif(closure)\r\n\t\t{\r\n\t\t\t_._updateRecursion++;\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tresult = closure();\r\n\t\t\t}\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\t_._updateRecursion--;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tresult = _._updateRecursion==0;\r\n\r\n\t\tif(result && _._updateRecursion==0)\r\n\t\t\t_._onUpdated();\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// ICollection<T>\r\n\t/////////////////////////////////////////\r\n\tget isReadOnly():boolean { return false; }\r\n\r\n\tprotected abstract getCount():number;\r\n\r\n\tget count():number { return this.getCount(); }\r\n\r\n\tadd(item:KeyValuePair<TKey, TValue>):void\r\n\t{\r\n\t\tif(!item)\r\n\t\t\tthrow new ArgumentNullException(\r\n\t\t\t\t'item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.'\r\n\t\t\t);\r\n\r\n\t\textractKeyValue(item,\r\n\t\t\t(key, value)=>this.addByKeyValue(key, value));\r\n\t}\r\n\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, keys = _.keys, count = keys.length;\r\n\r\n\t\tif(count)\r\n\t\t\t_.handleUpdate(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tkeys.forEach(key=> { _.removeByKey(key); });\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\tif(_.count!=0) // After they've all been removed, then should be zero.\r\n\t\t\tconsole.warn(\"Dictionary clear() results in mismatched count.\");\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tcontains(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\t// Should never have a null object in the collection.\r\n\t\tif(!item) return false;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn areEqual(value, v);\r\n\t\t\t});\r\n\r\n\t}\r\n\r\n\tcopyTo(array:IKeyValuePair<TKey, TValue>[], index:number = 0):IKeyValuePair<TKey, TValue>[]\r\n\t{\r\n\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\t// This is a generic implementation that will work for all derived classes.\r\n\t\t// It can be overridden and optimized.\r\n\t\tvar e = this.getEnumerator();\r\n\t\twhile(e.moveNext()) // Disposes when finished.\r\n\t\t{\r\n\t\t\tarray[index++] = e.current;\r\n\t\t}\r\n\t\treturn array;\r\n\t}\r\n\r\n\r\n\ttoArray():IKeyValuePair<TKey,TValue>[]\r\n\t{\r\n\t\treturn this.copyTo([], 0);\r\n\t}\r\n\r\n\tremove(item:IKeyValuePair<TKey, TValue>|[TKey,TValue]):number\r\n\t{\r\n\t\tif(!item) return 0;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn (areEqual(value, v) && this.removeByKey(key))\r\n\t\t\t\t\t? 1 : 0;\r\n\t\t\t});\r\n\r\n\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// IDictionary<TKey,TValue>\r\n\t/////////////////////////////////////////\r\n\r\n\tprotected abstract getKeys():TKey[];\r\n\r\n\tget keys():TKey[] { return this.getKeys(); }\r\n\r\n\tprotected abstract getValues():TValue[];\r\n\r\n\tget values():TValue[] { return this.getValues(); }\r\n\r\n\r\n\taddByKeyValue(key:TKey, value:TValue):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_.containsKey(key))\r\n\t\t{\r\n\t\t\tvar ex = new InvalidOperationException(\"Adding a key/value when the key already exists.\");\r\n\t\t\tex.data['key'] = key;\r\n\t\t\tex.data['value'] = value;\r\n\t\t\tthrow ex;\r\n\t\t}\r\n\r\n\t\t_.setValue(key, value);\r\n\t}\r\n\r\n\tabstract getValue(key:TKey):TValue;\r\n\r\n\tabstract setValue(key:TKey, value:TValue):boolean;\r\n\r\n\tcontainsKey(key:TKey):boolean\r\n\t{\r\n\t\tvar value = this.getValue(key);\r\n\t\treturn value!==VOID0;\r\n\t}\r\n\r\n\tcontainsValue(value:TValue):boolean\r\n\t{\r\n\t\tvar e = this.getEnumerator(), equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tif(equal(e.current, value, true))\r\n\t\t\t{\r\n\t\t\t\te.dispose();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveByKey(key:TKey):boolean\r\n\t{\r\n\t\treturn this.setValue(key, undefined);\r\n\t}\r\n\r\n\tremoveByValue(value:TValue):number\r\n\t{\r\n\t\tvar _ = this, count = 0, equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\t\t_.keys.forEach(key=>\r\n\t\t{\r\n\t\t\tif(equal(_.getValue(key), value, true))\r\n\t\t\t{\r\n\t\t\t\t_.removeByKey(key);\r\n\t\t\t\t++count;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn count;\r\n\t}\r\n\r\n\timportPairs(pairs:KeyValuePair<TKey, TValue>[]|IEnumerable<KeyValuePair<TKey, TValue>>):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(!pairs) return false;\r\n\t\treturn _.handleUpdate(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet changed:boolean = false;\r\n\t\t\t\tforEach(pairs,\r\n\t\t\t\t\tpair=>extractKeyValue(pair, (key, value)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t_.setValue(key, value);\r\n\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t})\r\n\t\t\t\t);\r\n\t\t\t\treturn changed;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar keys:TKey[], len:number, i = 0;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tkeys = _.keys;\r\n\t\t\t\tlen = keys.length\r\n\t\t\t},\r\n\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\twhile(i<len)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar key = keys[i++], value = _.getValue(key);\r\n\t\t\t\t\tif(value!==VOID0) // Still valid?\r\n\t\t\t\t\t\treturn yielder.yieldReturn({key: key, value: value});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport default DictionaryBase;","/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n'use strict';\nconst Compare_1 = require('../../Compare');\nconst EnumeratorBase_1 = require('../Enumeration/EnumeratorBase');\nconst ArgumentNullException_1 = require('../../Exceptions/ArgumentNullException');\nconst InvalidOperationException_1 = require('../../Exceptions/InvalidOperationException');\nconst KeyValueExtract_1 = require('../../KeyValueExtract');\nconst Enumerator_1 = require('../Enumeration/Enumerator');\nconst VOID0 = void (0);\nclass DictionaryBase {\n    constructor() {\n        this._updateRecursion = 0;\n    }\n    get isUpdating() { return this._updateRecursion != 0; }\n    _onValueUpdate(key, value, old) {\n        if (!Compare_1.areEqual(value, old, true)) {\n            var _ = this;\n            if (_.onValueChanged)\n                _.onValueChanged(key, value, old);\n            if (_._updateRecursion == 0)\n                _._onUpdated();\n        }\n    }\n    _onUpdated() {\n        var _ = this;\n        if (_.onUpdated)\n            _.onUpdated();\n    }\n    handleUpdate(closure) {\n        var _ = this, result;\n        if (closure) {\n            _._updateRecursion++;\n            try {\n                result = closure();\n            }\n            finally {\n                _._updateRecursion--;\n            }\n        }\n        else\n            result = _._updateRecursion == 0;\n        if (result && _._updateRecursion == 0)\n            _._onUpdated();\n        return result;\n    }\n    get isReadOnly() { return false; }\n    get count() { return this.getCount(); }\n    add(item) {\n        if (!item)\n            throw new ArgumentNullException_1.default('item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.');\n        KeyValueExtract_1.default(item, (key, value) => this.addByKeyValue(key, value));\n    }\n    clear() {\n        var _ = this, keys = _.keys, count = keys.length;\n        if (count)\n            _.handleUpdate(() => {\n                keys.forEach(key => { _.removeByKey(key); });\n                return true;\n            });\n        if (_.count != 0)\n            console.warn(\"Dictionary clear() results in mismatched count.\");\n        return count;\n    }\n    contains(item) {\n        if (!item)\n            return false;\n        return KeyValueExtract_1.default(item, (key, value) => {\n            let v = this.getValue(key);\n            return Compare_1.areEqual(value, v);\n        });\n    }\n    copyTo(array, index = 0) {\n        if (!array)\n            throw new ArgumentNullException_1.default('array');\n        var e = this.getEnumerator();\n        while (e.moveNext()) {\n            array[index++] = e.current;\n        }\n        return array;\n    }\n    toArray() {\n        return this.copyTo([], 0);\n    }\n    remove(item) {\n        if (!item)\n            return 0;\n        return KeyValueExtract_1.default(item, (key, value) => {\n            let v = this.getValue(key);\n            return (Compare_1.areEqual(value, v) && this.removeByKey(key))\n                ? 1 : 0;\n        });\n    }\n    get keys() { return this.getKeys(); }\n    get values() { return this.getValues(); }\n    addByKeyValue(key, value) {\n        var _ = this;\n        if (_.containsKey(key)) {\n            var ex = new InvalidOperationException_1.default(\"Adding a key/value when the key already exists.\");\n            ex.data['key'] = key;\n            ex.data['value'] = value;\n            throw ex;\n        }\n        _.setValue(key, value);\n    }\n    containsKey(key) {\n        var value = this.getValue(key);\n        return value !== VOID0;\n    }\n    containsValue(value) {\n        var e = this.getEnumerator(), equal = Compare_1.areEqual;\n        while (e.moveNext()) {\n            if (equal(e.current, value, true)) {\n                e.dispose();\n                return true;\n            }\n        }\n        return false;\n    }\n    removeByKey(key) {\n        return this.setValue(key, undefined);\n    }\n    removeByValue(value) {\n        var _ = this, count = 0, equal = Compare_1.areEqual;\n        _.keys.forEach(key => {\n            if (equal(_.getValue(key), value, true)) {\n                _.removeByKey(key);\n                ++count;\n            }\n        });\n        return count;\n    }\n    importPairs(pairs) {\n        var _ = this;\n        if (!pairs)\n            return false;\n        return _.handleUpdate(() => {\n            let changed = false;\n            Enumerator_1.forEach(pairs, pair => KeyValueExtract_1.default(pair, (key, value) => {\n                _.setValue(key, value);\n                changed = true;\n            }));\n            return changed;\n        });\n    }\n    getEnumerator() {\n        var _ = this;\n        var keys, len, i = 0;\n        return new EnumeratorBase_1.default(() => {\n            keys = _.keys;\n            len = keys.length;\n        }, (yielder) => {\n            while (i < len) {\n                var key = keys[i++], value = _.getValue(key);\n                if (value !== VOID0)\n                    return yielder.yieldReturn({ key: key, value: value });\n            }\n            return yielder.yieldBreak();\n        });\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DictionaryBase;\n"]}